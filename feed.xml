<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘蛟区块链博客</title>
    <description>区块链工程师</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 26 May 2018 10:13:45 +0800</pubDate>
    <lastBuildDate>Sat, 26 May 2018 10:13:45 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>拜占庭将军问题PBFT实用拜占庭容错</title>
        <description>&lt;h1 id=&quot;拜占庭将军问题&quot;&gt;拜占庭将军问题&lt;/h1&gt;
&lt;p&gt;BFT 拜占庭将军问题 30个节点当中必须有21个是可用的,才能完成这项任务&lt;/p&gt;

&lt;p&gt;客户端把信息”哈喽”给主节点A&lt;/p&gt;

&lt;p&gt;A发布信息”哈喽”给B,C,D&lt;/p&gt;

&lt;p&gt;B收到信息”哈喽”给A,C,D&lt;/p&gt;

&lt;p&gt;C收到信息”哈喽”给A,B,D&lt;/p&gt;

&lt;p&gt;D收到信息”哈喽”给A,B,C&lt;/p&gt;

&lt;p&gt;PBFT 实用拜占庭容错
信息广播后ABCD每个节点都有收到的”哈喽”,再把”哈喽”返回给客户端,
客户端收到ABCD回复的信息如果有有2条以上的 信息为”哈喽”,
那最终结果就是”哈喽”&lt;/p&gt;

&lt;p&gt;go来实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;os&quot;
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;io&quot;
)

//声明nodeInfo节点,代表各个小的王国
type nodeInfo struct {
	//节点名称
	id string
	//节点路径
	path string
	//http响应
	write http.ResponseWriter //跟终端进行交互
}

//创建map,存储各个国家的ip地址
var nodeTable = make(map[string]string)

func main() {
	//接收终端参数  先编译 然后运行./main 后面跟参数
	userID := os.Args[1] //1代表有一个参数
	fmt.Println(userID)
	//存储4个国家的Ip地址
	nodeTable = map[string]string{
		&quot;Apple&quot;:  &quot;localhost:11112&quot;,
		&quot;MS&quot;:     &quot;localhost:11113&quot;,
		&quot;Google&quot;: &quot;localhost:11114&quot;,
		&quot;IBM&quot;:    &quot;localhost:11115&quot;,
	}
	//创建国家对象
	node := nodeInfo{id: userID, path: nodeTable[userID]}
	//http协议的回调函数
	//http://localhost:1111/req?warTime=1111[0]&amp;amp;arTime=1112[1]
	http.HandleFunc(&quot;/req&quot;, node.request)
	//回调函数 通过/prePrepare
	http.HandleFunc(&quot;/prePrepare&quot;, node.prePrepare)
	//回调  通过/prepare
	http.HandleFunc(&quot;/prepare&quot;, node.prepare)
	http.HandleFunc(&quot;/commit&quot;,node.commit)

	//启动服务器  监听端口  如果有请求,会搜索handdleFunc里面的关键字
	 err := http.ListenAndServe(node.path, nil)
	if err != nil {
		fmt.Println(err)
	}

}
//writer http.ResponseWriter, request *http.Request固定格式
//http返回值					//https输入的值
//当http服务器,接收到网络请求并且/req 则回调request方法
func (node *nodeInfo) request(writer http.ResponseWriter, request *http.Request) {
	//该命令允许request请求参数
	//ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段

	request.ParseForm() //取参数  ?后面的参数
	if (len(request.Form[&quot;warTime&quot;]) &amp;gt; 0) {
		node.write = writer
		fmt.Println(&quot;主节点接收到的参数信息为&quot;, request.Form[&quot;warTime&quot;][0])
		//激活主节点后,向其他节点发送广播
		node.broadcast(request.Form[&quot;warTime&quot;][0], &quot;/prePrepare&quot;) //广播给其他节点
	}
}

//节点发送广播的方法
func (node *nodeInfo) broadcast(msg string, path string) { //msg要发送的内容 path要发送的ip地址和端口
	fmt.Println(&quot;广播&quot;, path) //1133
	//遍历所有节点
	for nodeId, url := range nodeTable {
		if nodeId == node.id { //如果是本身, 就跳过这次
			continue
		}
		//使当前节点外的节点做响应
		//向指定的url发出请求
		http.Get(&quot;http://&quot; + url + path + &quot;?warTime=&quot; + msg + &quot;&amp;amp;nodeId=&quot; + node.id)
	}
}

//接收广播后接收到的数据
func (node *nodeInfo) prePrepare(writer http.ResponseWriter, request *http.Request) {
	request.ParseForm() //啥意思?
	fmt.Println(&quot;接收到的广播&quot;, request.Form[&quot;warTime&quot;][0])
	//做判断
	if len(request.Form[&quot;warTime&quot;])&amp;gt;0{
		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prepare&quot;)

	}
}

//接收子节点的广播
func (node *nodeInfo) prepare(writer http.ResponseWriter, request *http.Request) {
	request.ParseForm()
	//打印消息
	fmt.Println(&quot;接收到的广播&quot;, request.Form[&quot;warTime&quot;][0])
	//校验
	if len(request.Form[&quot;warTime&quot;])&amp;gt;0{
		node.authentication(request)
	}

}

var authenticationNodeMap =make(map[string]string)
var authenticationSuceess = false

//校验拜占庭
func (node *nodeInfo)authentication(request *http.Request)  {
	if !authenticationSuceess{
		if len(request.Form[&quot;nodeId&quot;])&amp;gt;0{
			authenticationNodeMap[request.Form[&quot;nodeId&quot;][0]]=&quot;OK&quot;
			//如果存了两个国家节点成功正确的返回了结果 就是true
			if len(authenticationNodeMap)&amp;gt;len(nodeTable)/3{
				authenticationSuceess=true
				node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/commit&quot;)
			}

		}
	}
}

//返回成功响应
func (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request)  {
	if writer!=nil{
		fmt.Println(&quot;拜占庭校验成功&quot;)
	}
	io.WriteString(node.write,&quot;ok&quot;) //在网页显示
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/</guid>
        
        <category>共识算法</category>
        
        
      </item>
    
      <item>
        <title>Raft一致性算法</title>
        <description>&lt;h1 id=&quot;raft--一致性算法日志存储&quot;&gt;Raft  一致性算法日志存储&lt;/h1&gt;
&lt;p&gt;Raft 是一种为了管理复制日志的一致性算法&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;raft的工作模式是一个Leader和多个Follower模式，即我们通常说的领导者-追随者模式,这种模式下需要解决的第一个问题就是Leader的选举问题。其次是如何把日志从Leader复制到所有Follower上去。这里先不关心安全和可靠性，只理解raft运行起来基本规则。raft中的server有三种状态，除了已经提到的Leader和Follower状态外，还有Candidate状态，即竞选者状态。下面是这三种状态的转化过程。&lt;/p&gt;

&lt;p&gt;1、Leader的选举过程
初始所有节点都是&lt;strong&gt;追随者&lt;/strong&gt;,并开始随机睡眠(0-1000毫秒),最先醒来的变成&lt;strong&gt;竞选者&lt;/strong&gt;,竞选者可以给让其他节点给投票,当得到一半以上的票数,就当选成&lt;strong&gt;领导者&lt;/strong&gt;,只有&lt;strong&gt;领导者&lt;/strong&gt;才有权利接收客户端发来的委托请求,并像其他节点发送请求来保存日志.
2、日志复制过程
&lt;strong&gt;领导者&lt;/strong&gt;给所有&lt;strong&gt;追随者&lt;/strong&gt;发送保存日志请求,追随者收到请求后,判断是否满足条件,如果满足,追随者就保存在本地,并且给领导者发送保存成功的信息,领导者收到大部分追随者回复的信息之后,领导者就会正式提交把日志保存在本地,然后会给追随者发送本条日志的保存信息,(包括领导者ID和任期等),追随者会验证这些信息,确认刚才的日志已经被提交,正式把日志保存在本地,就意味着本条日志正式被Raft系统接受.
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3021998-8fecbddc9bc69558.png&quot; alt=&quot;GitHub set up&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;领导者&lt;/strong&gt;具有绝对的日志复制权力其它&lt;strong&gt;追随者&lt;/strong&gt;上存在日志不全或者与&lt;strong&gt;领导者&lt;/strong&gt;日志不一致的情况时，一切都以&lt;strong&gt;领导者&lt;/strong&gt;上的日志为主，最终所有server上的日志都会复制成与&lt;strong&gt;领导者&lt;/strong&gt;一致的状态。&lt;/p&gt;

&lt;p&gt;#安全性保证
1.&lt;strong&gt;领导者&lt;/strong&gt;正常运作时，会周期性地发出append_entries请求。这个周期性的append_entries除了可以更新其它Follower的log信息，另外一个重要功能就是起到心跳作用。Follower收到append_entries后，就知道&lt;strong&gt;领导者&lt;/strong&gt;还活着。如果Follower经过一个预定的时间(一般设为2000ms左右)都没有收到&lt;strong&gt;领导者&lt;/strong&gt;的心跳，就认为Leader挂了。于是转入Candidate状态，开始发起投票竞选新的&lt;strong&gt;领导者&lt;/strong&gt;。每个新的&lt;strong&gt;领导者&lt;/strong&gt;产生后就是一个新的任期，每个任期都对应一个唯一的任期号term。这个term是单调递增的，用来唯一标识一个&lt;strong&gt;领导者&lt;/strong&gt;的任期。投票开始时，Candidate将自己的term加1，并在request_vote中带上term；Follower只会接受任期号term比自己大的request_vote请求，并为之投票。这条规则保证了只有最新的Candidate才有可能成为&lt;strong&gt;领导者&lt;/strong&gt;。
2.同时有俩位竞选者一起竞选,谁票数多谁当选,如果一样多,就继续睡从新选.
3.如果宕机很久,就不能竞选位领导者,只有拥有最新日志的节点,才能成为领导者
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3021998-b3b95d8d2d1f4341.png&quot; alt=&quot;&quot; /&gt;
判断如果lastLogTerm比自己的term大，那么就可以给它投票；lastLogTerm比自己的term小，就不给它投票&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;4.如果新增加服务器,Raft会添加一个中间配置(Cold, Cnew)，这个中间配置的内容是旧的配置表Cold和新的配置Cnew,比如说server3在竞选Leader的时候，不仅需要得到Cold中的大部分投票，还要得到Cnew中的大部分投票才能成为Leader
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3021998-5f5dd0487c633705.png&quot; alt=&quot;&quot; /&gt;
5.提交之前任期内的日志条目
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3021998-4306d3847460eb68.png&quot; alt=&quot;&quot; /&gt;
如果在c图中s1挂掉之前,把日志提交给大部分节点,s5由于没有最新的日志4号,就无法当选领导人,也就无法出现D图中的问题.&lt;/p&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/Raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/Raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</guid>
        
        <category>共识算法</category>
        
        
      </item>
    
      <item>
        <title>RPC网络框架</title>
        <description>&lt;p&gt;RPC框架 
用我电脑调用别的电脑里的函数
server 本台电脑
Area方法在Rect类型里
用其它的cilent来链接server,调用Rect里的Area方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;raft注册到rpc&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc.Register(Rect) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rpc通过handle(路由器)可以通过网线或者无线把rpc到handle里面&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc.HandleHTTP()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rpc监听本机&lt;/strong&gt;  &lt;br /&gt;
通过tcp协议把自己作为主服务器去监听别的电脑或者客户端,参数有port(本机ip地址和接口)和handle(回调函数,回调go语言库defaultfunc,去比较本机的ip地址和其他电脑拨打的ip地址是否一致)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http.ListenAndServe(&quot;IP地址:端口号&quot;,&quot;nil&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他电脑进行拨打指定的ip地址及端口,如果和上边监听中的电脑ip地址一致,那么表示已经连上该机.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc1,err:=rpc.DialHTTP(&quot;TCP&quot;,&quot;要链接的IP地址:端口号&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;go实现服务器&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/rpc&quot;
	&quot;net/http&quot;
	&quot;log&quot;
)

//定义参数类型
type Params struct {
	Width, Height int
}

//声明对象
type Rect struct {
}

//定义公共方法 该方法在本机以外的方法也能调用
func (r *Rect) Area(p Params, ret *int) error {  //别人要调我的计算机的内存 所以要用指针
	*ret=p.Height*p.Width
	return nil
}

func (r *Rect)Perimtter(p Params, ret *int) error {
	*ret=(p.Width+p.Height)*2
	return nil

}

func main()  {
	//注册服务
	rect:=new(Rect)
	rpc.Register(rect)
	rpc.HandleHTTP() //不知道
	err:=http.ListenAndServe(&quot;:9090&quot;,nil)  //监听端头
	if err!=nil{
		log.Fatal(err)  //打印错误 并且写入日志
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;链接成功后返回rpc1,可以调用Call方法来调用server中的communication方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc1.Call(&quot;要调用的方法路径Rect.Area&quot;,&quot;要传入方法的参数&quot;,&quot;方法给的结果&amp;amp;&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;go实现客户端&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/rpc&quot;
	&quot;log&quot;
	&quot;fmt&quot;
)

//实现rpc客户端

type Params struct { //客户端要跟服务器保持一致
	Width, Height int
}

//调用服务器
func main() {
	//链接远程rpc
	rpc1,err:=rpc.DialHTTP(&quot;tcp&quot;,&quot;127.0.0.1:9090&quot;)//链接
	if err!=nil{
		log.Fatal(err)
	}
	ret:=0  //接收服务器传递的结果
	e:=rpc1.Call(&quot;Rect.Area&quot;,Params{100,100},&amp;amp;ret)

	if e!=nil{
		log.Fatal(e)
	}
	fmt.Println(ret)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果就是ret=100&lt;/p&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/RPC%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/RPC%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</guid>
        
        <category>RPC框架</category>
        
        
      </item>
    
      <item>
        <title>POW共识算法</title>
        <description>&lt;h1 id=&quot;pow共识算法&quot;&gt;pow共识算法&lt;/h1&gt;
&lt;p&gt;pow就是挖矿,工作量证明&lt;/p&gt;

&lt;p&gt;##区块数据结构
上一个节点的hash(prehHash)创始区块为0
当前节点的hash(HashCode)
区块高度(Index)
时间戳(time)
交易数据(Data)
nonce (每次+1 来进行hash碰撞)
难度系数 Diff =4(当前hash值前面就必须有4个0)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;把以上所有内容加起来,进行hash运算(sha256),来完成hash碰撞nonce值从0开始进行累计,交易数据会随机从未确认池中捞取,直到得到符合难度要要求的hash值,就是Pow挖矿成功,
Pow完成的区块向全网广播，其他节点将验证其是否符合规则，如果验证有效，其他节点将接收此区块，并附加在已有区块链之后。之后将进入下一轮挖矿。
如果有两个同时确认,两个区块会同时存在,再进行下一轮的挖矿,下一轮谁先挖到,就以谁的区块为准,另一条区块失效&lt;/p&gt;

&lt;p&gt;用go语言代码来实现pow挖矿&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//PoW proof-of-work  工作量证明算法
func pow(diff int, block *Block) string {
	for { //循环来产生区块的hash值 直到符合难度要求
		hash := GenerateBlockHashValue(*block)
		fmt.Println(hash)
		//hash值前面要有Diff个0
		if strings.HasPrefix(hash, strings.Repeat(&quot;0&quot;, diff)) {  //判断开头是不是diff个0  返回bool
			//挖矿成功
			fmt.Println(&quot;挖矿成功&quot;)
			return hash
		}else {
			block.Nonce++
		}

	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//生产区块的hash值
func GenerateBlockHashValue(block Block) string {
	//按照比特币的写法,将区块的所有的属性拼接后做Hash运算
	var hashdata = strconv.Itoa(block.Index) + block.Timestamp +
		strconv.Itoa(block.Diff) + strconv.Itoa(block.Nonce) + block.Data
	//进行hash运算
	var sha = sha256.New()
	sha.Write([]byte(hashdata))
	hashed := sha.Sum(nil)
	//将[]byte转换字符串
	return hex.EncodeToString(hashed)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;缺点 非常好资源 
比特币总量是有限的,到最后矿工就会很少,
最后没有奖励了,就会瘫痪&lt;/p&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/POW%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/POW%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/</guid>
        
        <category>共识算法</category>
        
        
      </item>
    
      <item>
        <title>POS共识算法</title>
        <description>&lt;h1 id=&quot;pos共识算法&quot;&gt;pos共识算法&lt;/h1&gt;
&lt;p&gt;###共识算法 pos(点点币)
—
大多数地方叫&lt;strong&gt;权益证明&lt;/strong&gt;，其实可以看作是股权证明，也是一种共识算法，在基于权益证明的数字货币中，下一个区块的选择是根据不同节点的股份和时间进行随机选择的。打个比方说，假如你买了1万个数字货币，然后就放在POS机制中，这样你就拥有了机会去获得新的区块从而得到奖励，机会有多大呢，就是那些拥有1千个数字货币的人的10倍概率，因为你有1万个，1万是1千的十倍，10%的股份分红是1%股份的10倍，道理是一样的。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;优势：不需要浪费算力，同时，进行51%攻击的代价更高，因为想要进行51%攻击的话，你得拥有51%的货币。也就是说，这东西越值钱，攻击的成本就越高&lt;/p&gt;

&lt;h2 id=&quot;pos的挖矿奖励是通过币零来计算的&quot;&gt;pos的挖矿奖励是通过币零来计算的&lt;/h2&gt;

&lt;p&gt;有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息，非常好！（需要注意的是，5%的年利率仅仅是举例，并非每个POS模式的币种都是5%，比如点点币PPCoin就是1%年利率）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;##POS的设计理念，来自于对比特币危机的思考，原因有三：
首先，我们都知道，比特币的区块产量每4年会减半，在不久的未来，随着比特币区块包含的产量越来越低，大家挖矿的动力将会不断下降，矿工人数越来越少，整个比特币网络有可能会逐渐陷入瘫痪(因为大家都减少了运行比特币客户端的时间，因此越来越难找到一个P2P节点去连接和同步网络数据)。
POS解决方案：在POS体系中，只有打开钱包客户端程序，才能发现POS区块，才会获得利息，这促使很多不想挖矿的人，也会常常打开自己的钱包客户端，这帮助了P2P货币网络的健壮。
其次，若干年后，随着矿工人数的下降，比特币很有可能被一些高算力的人、或团队、或矿池，进行51%攻击，导致整个比特币网络崩溃。51%攻击简单来说，就是当你拥有了超过全球51%的比特币算力时，你将能伪造比特币网络的任何数据，比如你伪造你有一百万个比特币但实际上你没有。(拓展阅读：什么是51%攻击)
POS解决方案：在POS体系中，即使你拥有了全球51%的算力，也未必能够进行51%攻击，因为，有一部分的货币并不是挖矿产生的，而是由利息产生(利息存放在POS区块中)，这要求攻击者还需要持有全球超过51%的货币量。这大大提高了51%攻击的难度。&lt;/p&gt;

&lt;p&gt;用go来实现pos算法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;strconv&quot;
	&quot;crypto/sha256&quot;
	&quot;encoding/hex&quot;
	&quot;time&quot;
	&quot;math/rand&quot;
	&quot;fmt&quot;
)

//常用共识算法 Pos pow Dpos 所有的共识算法都是为了解决挖矿问题
//pos共识算法的使用
//创建区块

type Block struct {
	BMP       int
	Perhash   string
	HashCode  string
	TimeStamp string
	Index     int
	validator string //区块验证者
}
//创建区块链
var Blockchain []Block


//区块hash算法 计算区块的hash值
func generateHashValue(block Block)string  {
	var hashcode=block.Perhash+block.HashCode+block.TimeStamp+block.validator+strconv.Itoa(block.BMP)+strconv.Itoa(block.Index)
		sha:=sha256.New()
		sha.Write([]byte(hashcode))
		hashed:=sha.Sum(nil)
		return hex.EncodeToString(hashed)

}

//生成新的区块  adds是矿工的地址
func GenerateNextblock(oldBlock Block,BMP int,adds string)Block  {
	newBlock:=Block{}
	newBlock.Index=oldBlock.Index+1
	newBlock.TimeStamp=time.Now().String()
	newBlock.HashCode=generateHashValue(newBlock)
	newBlock.Perhash=oldBlock.HashCode
	newBlock.validator=adds
	newBlock.BMP=BMP
	return newBlock

}
//点点币网路系统中的全节点
type Node struct {
	tokens int  //有多少币
	adds string //地址
}
//存放全节点
var n[2] Node  //节点 创建几个 就有几个用户
var addr[3000] string  //

func main() {
	//存放两个炒币者
	n[0]=Node{1000,&quot;abc123&quot;}  //第一个节点
	n[1]=Node{2000,&quot;bcd234&quot;}
	//以下为pos公式算法
	var cnt =0
	for i:=0;i&amp;lt;2;i++{
		for j :=0;j&amp;lt;n[i].tokens;j++{  //addr 数组赋值
			addr[cnt]=n[i].adds
			cnt++
		}
	}
	rand.Seed(time.Now().Unix())  //随机种子
	//通过随机值[0-3000)
	rd:=rand.Intn(3000)
	var adds=addr[rd]

	//生成创始区块
	firstBlock:=Block{}
	firstBlock.BMP=100
	firstBlock.Perhash=&quot;0&quot;
	firstBlock.TimeStamp=time.Now().String()
	firstBlock.validator=&quot;abc123&quot;
	firstBlock.Index=1
	firstBlock.HashCode=generateHashValue(firstBlock)

	//将创始区块添加的区块链
	Blockchain=append(Blockchain,firstBlock)
	//挖矿成功
	var sceondBlock=GenerateNextblock(firstBlock,200,adds)
	//把下一个区块存取区块链
	Blockchain=append(Blockchain,sceondBlock)
	fmt.Println(Blockchain)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/POS%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/POS%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/</guid>
        
        <category>共识算法</category>
        
        
      </item>
    
      <item>
        <title>DPOS共识算法</title>
        <description>&lt;h1 id=&quot;dpos共识算法&quot;&gt;Dpos共识算法&lt;/h1&gt;
&lt;h2 id=&quot;什么是-dpos&quot;&gt;什么是 DPoS&lt;/h2&gt;

&lt;p&gt;DPoS 即 Delegated Proof of Stake 译为股份授权证明。
最早于2013年由比特股Bitshares提出，目的为解决PoW和PoS机制的不足&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;持币人可以进行投票,选出代表自己的受托人,受托人的权益是相等的,可以进行轮流挖矿的,并按照个人的持股比例获得“利息”&lt;/strong&gt;
相较于PoW每10分钟产生一个区块，DPoS每3秒钟即可产生一个区块,效率大大提高.&lt;/p&gt;

&lt;p&gt;###对恶意节点的惩罚
注册成为候选受托人需要支付一笔保证金，就像是参与民意代表选举前缴纳的保证金一样，一般来说担任受托人约两周后才可达到损益平衡，这促进了受托人的稳定性，确保至少会挖满两周的矿。
惩罚机制为：不按排程产生区块的节点将在下一轮被投票剔除，也会被没收之前缴纳的保证金。
DPoS是效率较PoW和PoS更高、产生区块的速度更快；
虽然恶意的节点将在下一轮投票被踢出，但单个恶意区块在短期仍有可能是有效的状态。
短期虽然可能存在恶意区块，但长期下来，可以透过受托人的自主选择来回归链条的有效性
假定现在总共有3个受托人A、Ｂ、Ｃ，D加入排程后，只要确认之前的区块中，有2/3以上个受托人遵循的链是哪条就可以了。&lt;/p&gt;

&lt;p&gt;##DPoS的优缺点
###优点
能耗更低。DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。
更加去中心化。目前，对于比特币而言，个人挖矿已经不现实了，比特币的算力都集中在几个大的矿池手里，每个矿池都是中心化的，就像DPoS的一个受托人，因此DPoS机制的加密货币更加去中心化。PoS机制的加密货币（比如未来币），要求用户开着客户端，事实上用户并不会天天开着电脑，因此真正的网络节点是由几个股东保持的，去中心化程度也不能与DPoS机制的加密货币相比。
更快的确认速度。每个块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的101个块的周期大概仅仅需要16分钟。而比特币（PoW机制）产生一个区块需要10分钟，一笔交易完成（6个区块确认后）需要1个小时。点点币（PoS机制）确认一笔交易大概也需要1小时。
###缺点
投票的积极性并不高。绝大多数持股人（90％+）从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。
对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患。&lt;/p&gt;

&lt;p&gt;go语言实现Dpos共识算法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;strconv&quot;
	&quot;crypto/sha256&quot;
	&quot;encoding/hex&quot;
	&quot;time&quot;
	&quot;math/rand&quot;
	&quot;fmt&quot;
)

//Dpos共识算法 原理

type Block struct {
	Index int
	PreHash string
	HashCode string
	BMP int
	Validator string   //区块验证者
	TimeStamp string
}

//区块链 用数组维护区块

var blockchian []Block

//生成Block
func generateNextBlock(oldBlock Block,BMP int,adds string)Block  {
	newBlock:=Block{}
	newBlock.Index=oldBlock.Index+1
	newBlock.PreHash=oldBlock.HashCode
	newBlock.BMP=BMP
	newBlock.TimeStamp=time.Now().String()
	newBlock.HashCode=generateHashValue(newBlock)
	newBlock.Validator=adds

	return newBlock
}


//产生区块的hash值
func generateHashValue(block Block)string  {
	var hashcode=block.PreHash+block.Validator+block.TimeStamp+
		strconv.Itoa(block.Index)+strconv.Itoa(block.BMP)
		sha:=sha256.New()
		sha.Write([]byte(hashcode))
		hashed:=sha.Sum(nil)
		return hex.EncodeToString(hashed)

}

//存放代理人 代理人的地址信息
var delgate =[]string {&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;}

//随机调换委托人的位置
func RandDelegate(){
	rand.Seed(time.Now().Unix())
	r:=rand.Intn(4)
	t:=delgate[r]
	delgate[r]=delgate[3]
	delgate[3]=t
}

func main()  {
	//创始区块
	RandDelegate()
	var firstBlock Block
	blockchian=append(blockchian,firstBlock)  //把创始区块放到链里
	//通过变量n按顺序让delegat作为矿工

	n:=0

	for{
		//每三秒产生一个区块
		time.Sleep(3*time.Second)
		nextBlock:=generateNextBlock(firstBlock,1,delgate[n])   //区块验证者地址
		n++
		n=n%len(delgate) //轮流让受信人挖矿
		firstBlock=nextBlock //创始=下一个区块
		blockchian=append(blockchian,nextBlock) // 把新创建的区块加到链里
		fmt.Println(blockchian)
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/DPOS%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/DPOS%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/</guid>
        
        <category>共识算法</category>
        
        
      </item>
    
      <item>
        <title>零知识证明</title>
        <description>&lt;h1 id=&quot;零知识证明&quot;&gt;零知识证明&lt;/h1&gt;

&lt;p&gt;什么是零知识证明
零知识证明(Zero—Knowledge Proof)，是由S.Goldwasser、S.Micali及C.Rackoff在20世纪80年代初提出的。它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。大量事实证明，零知识证明在密码学中非常有用。如果能够将零知识证明用于验证，将可以有效解决许多问题。&lt;/p&gt;

&lt;h2 id=&quot;通俗来将就是不给对方透露任何信息让对方相信你又这个能力&quot;&gt;通俗来将就是,不给对方透露任何信息,让对方相信,你又这个能力&lt;/h2&gt;
&lt;p&gt;比如有一个房间只能用钥匙打开,A要向B证明A有钥匙,
B知道房间里有一件特殊的物体X其他人不知道,A可以通过告诉B,特殊物体的信息,来证明自己有钥匙可以进入到房间内&lt;/p&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/20/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/20/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>go语言实现椭圆曲线ECC加密算法,签名和验签</title>
        <description>&lt;h1 id=&quot;go语言实现椭圆曲线ecc加密的签名和验签&quot;&gt;go语言实现椭圆曲线ECC加密的签名和验签&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。&lt;/p&gt;

&lt;p&gt;　　椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。
　　
—&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;验证签名就是通过明文进行hash运算,然后跟签名中明文的hash进行比对&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;go语言实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;crypto/ecdsa&quot;
	&quot;crypto/elliptic&quot;
	&quot;crypto/rand&quot;
	&quot;crypto/sha256&quot;
	&quot;math/big&quot;
	&quot;fmt&quot;
)

//通过椭圆曲线完成签名和验证
func main()  {
	//声明明文
	message:=[]byte(&quot;hello world&quot;)
	//生成私钥   elliptic.P256椭圆曲线法则
	privateKey,_:=ecdsa.GenerateKey(elliptic.P256(),rand.Reader)
	//生成公钥
	pub:=privateKey.PublicKey
	//将明文进行hash散列 数组
	digest:=sha256.Sum256(message)
	//签名
	r,s,_:=ecdsa.Sign(rand.Reader,privateKey,digest[:])//切片
	//设置私钥参数类型为Curve是曲线类型
	param:=privateKey.Curve.Params()
	//获得私钥长度                   把参数里的位求出来/8 = 求出字节[]byte长度  有自动补码
	curveOrderByteSize:=param.P.BitLen()/8
	//求出s,r,的字节长度  签名返回值的字节长度
	rByte,sByte:=r.Bytes(),s.Bytes()
	fmt.Println(r,rByte)
	//创建签名数组, 长度是字节的两倍
	signature:=make([]byte,curveOrderByteSize*2)

	//通过数组,保存了签名结果返回值
	copy(signature[curveOrderByteSize-len(rByte):],rByte)
	copy(signature[curveOrderByteSize*2-len(sByte):],sByte)
	//认证
	//将明文做hash散列,为了验证的对比
	digest= sha256.Sum256(message)
	//获得公钥长度
	curveOrderByteSize=pub.Curve.Params().P.BitLen()/8
	//创建俩个整形对象
	r,s =new(big.Int),new(big.Int)
	//设置证书值
	r.SetBytes(signature[:curveOrderByteSize])
	s.SetBytes(signature[curveOrderByteSize:])
	//认证
	e:=ecdsa.Verify(&amp;amp;pub,digest[:],r,s)
	if e==true{
		fmt.Println(&quot;ok&quot;)

	}else {
		fmt.Println(&quot;failed&quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果验签成功返回 ok
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BFECC%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BFECC%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>go语言实现RSA加密算法,签名和验签</title>
        <description>&lt;h1 id=&quot;go语言实现rsa签名和验签&quot;&gt;go语言实现RSA签名和验签&lt;/h1&gt;

&lt;p&gt;签名通过私钥对明文进行hash MD5运算,进行签名
验签通过公钥对明文进行hash MD5运算,进行验签&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
&quot;crypto/rsa&quot;
&quot;crypto/rand&quot;
&quot;crypto/md5&quot;
&quot;crypto&quot;
&quot;fmt&quot;
	&quot;encoding/base64&quot;
)

//RSA 实现签名和验证签
func main()  {
	//生成私钥
	priv,_:=rsa.GenerateKey(rand.Reader,1024)
	//产生公钥
	pub:=&amp;amp;priv.PublicKey
	fmt.Println(pub)
	//设置明文
	plaintext:=[]byte(&quot;hello&quot;)

	//先给明文做hash散列加密
	h:=md5.New()
	h.Write(plaintext)
	hashed:=h.Sum(nil)

	//签名
	opts:=&amp;amp;rsa.PSSOptions{SaltLength:rsa.PSSSaltLengthAuto,Hash:crypto.MD5}  //签名算法
	sig,_:=rsa.SignPSS(rand.Reader,priv,crypto.MD5,hashed,opts)
	fmt.Println(base64.StdEncoding.EncodeToString(sig))
	//认证
	e:=rsa.VerifyPSS(pub,crypto.MD5,hashed,sig,opts)
	if e==nil{
		fmt.Println(&quot;认证成功&quot;)

	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;e的值为空,证明验证成功
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>go语言实现非对称RSA加密算法</title>
        <description>&lt;h1 id=&quot;go实现非对称加密rsa&quot;&gt;go实现非对称加密RSA&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;RSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。&lt;/p&gt;

&lt;p&gt;RSA可以被用于公钥密码和数字签名。
　　
—
非对称加密会生成一对密钥
&lt;strong&gt;公钥 用来加密明文和验证签名&lt;/strong&gt;
&lt;strong&gt;密钥 用来解密密文和发送签名&lt;/strong&gt;
可以先用openssl来生成一对密钥&lt;/p&gt;

&lt;h2 id=&quot;openssl生成私钥&quot;&gt;openssl生成私钥&lt;/h2&gt;
&lt;p&gt;打开终端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;openssl genrsa -out rsa_private_key.pem 1024  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;openssl生成公钥&quot;&gt;openssl生成公钥&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##go实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//公钥加密
func RsaEncrypt(origData []byte) []byte {
	block,_:=pem.Decode(publicKey) //把文件放在pem里转成block
	pubInterface,_:=x509.ParsePKIXPublicKey(block.Bytes)//解析公钥
	pub:=pubInterface.(*rsa.PublicKey) //设置刚才的公钥确实是Public 类型  类型断言
	bts,_:=rsa.EncryptPKCS1v15(rand.Reader,pub,origData)//加密[]byte(&quot;hello world&quot;)
	return bts
}

func RsaDecrypt(origData []byte)[]byte  {
	//解密
	block,_:=pem.Decode(pirvateKey) //私钥放在pem里转成block
	//解析私钥
	priv,_:=x509.ParsePKCS1PrivateKey(block.Bytes)
	//解密
	bts,_:=rsa.DecryptPKCS1v15(rand.Reader,priv,origData)
	return bts

}

func main()  {
	e:=RsaEncrypt([]byte(&quot;hello wold&quot;))
	fmt.Println(&quot;密文&quot;,base64.StdEncoding.EncodeToString(e)) //字节码转换成字符串
	r:=RsaDecrypt(e)
	fmt.Println(string(r))


}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;密文 blqAd7iBbtv67OjkgaL6JZKN4WZOsjvRK+vLmT9ZxEl5KK1aCXQBAhp024SKtAqXInzGHMyy2Y7+bEkvv5zmTulcaZUzxas7/azw0oS+Hu24m3NY8QMXcWlvAcEq481iWs8CJCda8b4l32bXD3CS/5oFNSx5KQW6z/hoeLrjk9kp9DisXcUnZq1mss1A7I5V0r2Iv/YJa9RNg29MCdH309lHV/NBAI2gkFUA33jnkHR/s3UEfR19fn9KfT06zMURm57qcyV78f3QcJhUvKyJPHxpM4Xyz+am6y/tVCIRzVCmACRd8Drj6ZUU8POc+MUyM9jhDrQtJJ7edQUwTI9A7A==
hello wold
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
  </channel>
</rss>
