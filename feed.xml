<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘蛟区块链博客</title>
    <description>区块链工程师</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 20 May 2018 10:59:29 +0800</pubDate>
    <lastBuildDate>Sun, 20 May 2018 10:59:29 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>零知识证明</title>
        <description>&lt;h1 id=&quot;零知识证明&quot;&gt;零知识证明&lt;/h1&gt;

&lt;p&gt;什么是零知识证明
零知识证明(Zero—Knowledge Proof)，是由S.Goldwasser、S.Micali及C.Rackoff在20世纪80年代初提出的。它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。大量事实证明，零知识证明在密码学中非常有用。如果能够将零知识证明用于验证，将可以有效解决许多问题。&lt;/p&gt;

&lt;h2 id=&quot;通俗来将就是不给对方透露任何信息让对方相信你又这个能力&quot;&gt;通俗来将就是,不给对方透露任何信息,让对方相信,你又这个能力&lt;/h2&gt;
&lt;p&gt;比如有一个房间只能用钥匙打开,A要向B证明A有钥匙,
B知道房间里有一件特殊的物体X其他人不知道,A可以通过告诉B,特殊物体的信息,来证明自己有钥匙可以进入到房间内&lt;/p&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/20/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/20/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>go语言实现椭圆曲线ECC加密算法,签名和验签</title>
        <description>&lt;h1 id=&quot;go语言实现椭圆曲线ecc加密的签名和验签&quot;&gt;go语言实现椭圆曲线ECC加密的签名和验签&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。&lt;/p&gt;

&lt;p&gt;　　椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。
　　
—&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;验证签名就是通过明文进行hash运算,然后跟签名中明文的hash进行比对&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;go语言实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;crypto/ecdsa&quot;
	&quot;crypto/elliptic&quot;
	&quot;crypto/rand&quot;
	&quot;crypto/sha256&quot;
	&quot;math/big&quot;
	&quot;fmt&quot;
)

//通过椭圆曲线完成签名和验证
func main()  {
	//声明明文
	message:=[]byte(&quot;hello world&quot;)
	//生成私钥   elliptic.P256椭圆曲线法则
	privateKey,_:=ecdsa.GenerateKey(elliptic.P256(),rand.Reader)
	//生成公钥
	pub:=privateKey.PublicKey
	//将明文进行hash散列 数组
	digest:=sha256.Sum256(message)
	//签名
	r,s,_:=ecdsa.Sign(rand.Reader,privateKey,digest[:])//切片
	//设置私钥参数类型为Curve是曲线类型
	param:=privateKey.Curve.Params()
	//获得私钥长度                   把参数里的位求出来/8 = 求出字节[]byte长度  有自动补码
	curveOrderByteSize:=param.P.BitLen()/8
	//求出s,r,的字节长度  签名返回值的字节长度
	rByte,sByte:=r.Bytes(),s.Bytes()
	fmt.Println(r,rByte)
	//创建签名数组, 长度是字节的两倍
	signature:=make([]byte,curveOrderByteSize*2)

	//通过数组,保存了签名结果返回值
	copy(signature[curveOrderByteSize-len(rByte):],rByte)
	copy(signature[curveOrderByteSize*2-len(sByte):],sByte)
	//认证
	//将明文做hash散列,为了验证的对比
	digest= sha256.Sum256(message)
	//获得公钥长度
	curveOrderByteSize=pub.Curve.Params().P.BitLen()/8
	//创建俩个整形对象
	r,s =new(big.Int),new(big.Int)
	//设置证书值
	r.SetBytes(signature[:curveOrderByteSize])
	s.SetBytes(signature[curveOrderByteSize:])
	//认证
	e:=ecdsa.Verify(&amp;amp;pub,digest[:],r,s)
	if e==true{
		fmt.Println(&quot;ok&quot;)

	}else {
		fmt.Println(&quot;failed&quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果验签成功返回 ok
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BFECC%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BFECC%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>go语言实现RSA加密算法,签名和验签</title>
        <description>&lt;h1 id=&quot;go语言实现rsa签名和验签&quot;&gt;go语言实现RSA签名和验签&lt;/h1&gt;

&lt;p&gt;签名通过私钥对明文进行hash MD5运算,进行签名
验签通过公钥对明文进行hash MD5运算,进行验签&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
&quot;crypto/rsa&quot;
&quot;crypto/rand&quot;
&quot;crypto/md5&quot;
&quot;crypto&quot;
&quot;fmt&quot;
	&quot;encoding/base64&quot;
)

//RSA 实现签名和验证签
func main()  {
	//生成私钥
	priv,_:=rsa.GenerateKey(rand.Reader,1024)
	//产生公钥
	pub:=&amp;amp;priv.PublicKey
	fmt.Println(pub)
	//设置明文
	plaintext:=[]byte(&quot;hello&quot;)

	//先给明文做hash散列加密
	h:=md5.New()
	h.Write(plaintext)
	hashed:=h.Sum(nil)

	//签名
	opts:=&amp;amp;rsa.PSSOptions{SaltLength:rsa.PSSSaltLengthAuto,Hash:crypto.MD5}  //签名算法
	sig,_:=rsa.SignPSS(rand.Reader,priv,crypto.MD5,hashed,opts)
	fmt.Println(base64.StdEncoding.EncodeToString(sig))
	//认证
	e:=rsa.VerifyPSS(pub,crypto.MD5,hashed,sig,opts)
	if e==nil{
		fmt.Println(&quot;认证成功&quot;)

	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;e的值为空,证明验证成功
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>go语言实现非对称RSA加密算法</title>
        <description>&lt;h1 id=&quot;go实现非对称加密rsa&quot;&gt;go实现非对称加密RSA&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;RSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。&lt;/p&gt;

&lt;p&gt;RSA可以被用于公钥密码和数字签名。
　　
—
非对称加密会生成一对密钥
&lt;strong&gt;公钥 用来加密明文和验证签名&lt;/strong&gt;
&lt;strong&gt;密钥 用来解密密文和发送签名&lt;/strong&gt;
可以先用openssl来生成一对密钥&lt;/p&gt;

&lt;h2 id=&quot;openssl生成私钥&quot;&gt;openssl生成私钥&lt;/h2&gt;
&lt;p&gt;打开终端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;openssl genrsa -out rsa_private_key.pem 1024  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;openssl生成公钥&quot;&gt;openssl生成公钥&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##go实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//公钥加密
func RsaEncrypt(origData []byte) []byte {
	block,_:=pem.Decode(publicKey) //把文件放在pem里转成block
	pubInterface,_:=x509.ParsePKIXPublicKey(block.Bytes)//解析公钥
	pub:=pubInterface.(*rsa.PublicKey) //设置刚才的公钥确实是Public 类型  类型断言
	bts,_:=rsa.EncryptPKCS1v15(rand.Reader,pub,origData)//加密[]byte(&quot;hello world&quot;)
	return bts
}

func RsaDecrypt(origData []byte)[]byte  {
	//解密
	block,_:=pem.Decode(pirvateKey) //私钥放在pem里转成block
	//解析私钥
	priv,_:=x509.ParsePKCS1PrivateKey(block.Bytes)
	//解密
	bts,_:=rsa.DecryptPKCS1v15(rand.Reader,priv,origData)
	return bts

}

func main()  {
	e:=RsaEncrypt([]byte(&quot;hello wold&quot;))
	fmt.Println(&quot;密文&quot;,base64.StdEncoding.EncodeToString(e)) //字节码转换成字符串
	r:=RsaDecrypt(e)
	fmt.Println(string(r))


}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;密文 blqAd7iBbtv67OjkgaL6JZKN4WZOsjvRK+vLmT9ZxEl5KK1aCXQBAhp024SKtAqXInzGHMyy2Y7+bEkvv5zmTulcaZUzxas7/azw0oS+Hu24m3NY8QMXcWlvAcEq481iWs8CJCda8b4l32bXD3CS/5oFNSx5KQW6z/hoeLrjk9kp9DisXcUnZq1mss1A7I5V0r2Iv/YJa9RNg29MCdH309lHV/NBAI2gkFUA33jnkHR/s3UEfR19fn9KfT06zMURm57qcyV78f3QcJhUvKyJPHxpM4Xyz+am6y/tVCIRzVCmACRd8Drj6ZUU8POc+MUyM9jhDrQtJJ7edQUwTI9A7A==
hello wold
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 20 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/20/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E5%AF%86/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>go语言实现对称AES加密算法</title>
        <description>&lt;h2 id=&quot;go语言实现aes加密算法&quot;&gt;#go语言实现AES加密算法&lt;/h2&gt;
&lt;p&gt;AES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。
　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。
　　
AES同样需要加密前补码,解密后取码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//补码
func PKCS7Paading(ciphertext []byte,blocksize int )[]byte  { //传入不同的密钥长度
	//传入密钥分组后的长度-要加密的明文的长度%密钥分组后的长度
	//要补的位数
	//把要补的位数补上
	padding:=blocksize-len(ciphertext)%blocksize
	padtext:=bytes.Repeat([]byte{byte(padding)},padding)
	return append(ciphertext,padtext...)
	//padding:=blocksize-len(ciphertext)%blocksize
	//padtext:=bytes.Repeat([]byte{byte(padding)},padding)
	//return append(ciphertext,padtext...)

}
//去码
func PKCS7UnPaading(origData []byte)[]byte  {
	//确定解密后的长度
	//取到切片最后一个下标的值
	//返回补码的数量总长度-最后的值
	length:=len(origData)
	unpadding:=int(origData[length-1])
	return origData[:length-unpadding]
	//length:=len(origData)
	//unpadding:=int(origData[length-1])
	//return origData[:(length-unpadding)]

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;补码后就可以进行加密了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//加密
func AesEncrypt(origData,key[]byte)[]byte  {
	//密钥分组
	//密钥长度
	//补码
	//加密模式
	//创建数组
	//加密
	//返回加密数组


	block,_:=aes.NewCipher(key) //密钥分组
	blocksize:=block.BlockSize()  //密钥长度
	fmt.Println(blocksize)
	origData=PKCS7Paading(origData,blocksize)//补码
	blockMode:=cipher.NewCBCEncrypter(block,key[:blocksize])//加密模式
	cryted:=make([]byte,len(origData))//创建数组
	blockMode.CryptBlocks(cryted,origData)//加密
	return cryted  //返回加密数组
}
func AesDecrypt(cryted,key []byte)[]byte  {
	block,_:=aes.NewCipher(key)  //密钥分组
	blocksize:=block.BlockSize()//密钥长度
	blockMode:=cipher.NewCBCDecrypter(block,key[:blocksize]) //解密方式
	origData:=make([]byte,len(cryted)) //创建数组
	blockMode.CryptBlocks(origData,cryted)  //解密到数组里面去
	origData=PKCS7UnPaading(origData) //解密完去码
	return origData

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;主函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main()  {
	//var key16  =[]byte(&quot;1234567812345678&quot;)//aes 密钥长度 16 24 32 字节
	var key24  =[]byte(&quot;12345678123456781234567812345678&quot;)
	a:=AesEncrypt([]byte(&quot;abc&quot;),key24)
	fmt.Println(base64.StdEncoding.EncodeToString(a))
	b:=AesDecrypt(a,key24)
	fmt.Println(string(b))

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;输出结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;密文: SwJ8j0Tx6HzCyft1FXa0Pg==
明文: abc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 19 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/19/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0AES%E5%8A%A0%E5%AF%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/19/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0AES%E5%8A%A0%E5%AF%86/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>密码学密码学对称加密算法DES和3DES</title>
        <description>&lt;h1 id=&quot;go密码学对称加密算法des和3des&quot;&gt;go密码学对称加密算法DES和3DES&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;加密模式&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;ECB模式&lt;/strong&gt; 全称Electronic Codebook模式，译为电子密码本模式(由于安全性差,已经被淘汰)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CBC模式&lt;/strong&gt; 全称Cipher Block Chaining模式，译为密文分组链接模式(分组模式)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CFB模式&lt;/strong&gt; 全称Cipher FeedBack模式，译为密文反馈模式(流模式)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;OFB模式&lt;/strong&gt; 全称Output Feedback模式，译为输出反馈模式。(流模式)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CTR模式&lt;/strong&gt; 全称Counter模式，译为计数器模式。(流模式)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;des加密算法可解密可加密&quot;&gt;DES加密算法(可解密可加密)&lt;/h2&gt;
&lt;p&gt;DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组，分组有很多模式，后续单独总结，暂时先介绍DES加密算法。DES使用的密钥长度为64比特，但由于每隔7个比特设置一个奇偶校验位，因此其密钥长度实际为56比特。奇偶校验为最简单的错误检测码，即根据一组二进制代码中1的个数是奇数或偶数来检测错误。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;DES加密需要先将密码分组,然后把要加密的明文进行PKCS5Padding进行补码,既8位取余,余几位,补几位,解密后同样要把后面补的几位去掉,&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;go语言实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;加密&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//DES对称性加密
//DES 有不同的加密模式(5种)本次采用CBC加密模式
func MyDesEncrypt(origData,key []byte)  {  //origData 明文
	//把钥匙传进来加密 换成block块
	block,_:=des.NewCipher(key) //密钥分组
	//将明文按密钥长度做补码运算
	origData=PKCS5Padding(origData,block.BlockSize())
	//设置加密方式
	blockMode :=cipher.NewCBCEncrypter(block,key) //CBC加密方式
	//创建明文长度的字节数组
	crypted:=make([]byte,len(origData))
	//加密明文
	blockMode.CryptBlocks(crypted,origData)
	//将字节数组转换成字符串 转成base64 类型
	fmt.Printf(base64.StdEncoding.EncodeToString(crypted))

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;补码&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//实现去除补码
func PKCS5Unpandding(origData []byte) []byte {
	length:=len(origData) //计算长度
	unpadding:=int(origData[length-1])//把最后一个值拿出来
	return origData[:(length-unpadding)]

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解密&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//DES解密方法
func MyDESDecrypt(data string,key []byte)  {
	//将字符串转换成字节数组[]byte
	crypted, _ := base64.StdEncoding.DecodeString(data)//将字符串转成[]byte数组
	//fmt.Println(crypted)
	block,_:=des.NewCipher(key)//将字节密钥转换成block块 ,密钥分组
	//设置解密方式
	blockMode:=cipher.NewCBCDecrypter(block,key)
	//创建密文大小的[]byte切片
	origData:=make([]byte,len(crypted))
	//解密密文到数组origData中
	blockMode.CryptBlocks(origData,crypted)
	//除去补码
	origData=PKCS5Unpandding(origData)
	//打印明文
	fmt.Println(string(origData))

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;去码&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func PKCS5Padding(ciphertext []byte,blockSize int)  []byte{ //实现明文的补码
	padding:=blockSize-len(ciphertext)%blockSize //查看需要补几位 比如差3位
	padtext:=bytes.Repeat([]byte{byte(padding)},padding)//重复几位将里面的 这里就补333
	return append(ciphertext,padtext...)  //append[]byte 后面需要加...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;方法调用&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main()  {
//声明密钥 利用此密钥 实现明文的加密和密文的解密
key:=[]byte(&quot;12345678&quot;) //长度为8
	//加密
	MyDesEncrypt([]byte(&quot;hello kong yia&quot;),key)
	//解密
	MyDESDecrypt(&quot;6xl7sC7Om9o+lQ1S2j1U6g==&quot;,key)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;输出结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6xl7sC7Om9o+lQ1S2j1U6g==hello kong yia
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;3des-加密及解密&quot;&gt;3DES 加密及解密&lt;/h2&gt;
&lt;p&gt;DES的升级版,24字节的密钥分为,分为3组分别进行加密,以提高安全性&lt;/p&gt;

&lt;h3 id=&quot;加密&quot;&gt;加密&lt;/h3&gt;

&lt;p&gt;对比DES，发现只是换了NewTripleDESCipher。不过，需要注意的是，密钥长度必须24byte，否则直接返回错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
//补码
func PKCS5padding(ciphertext []byte,blocksize int)[]byte  {
	padding:=blocksize-len(ciphertext)%blocksize  //%24
	padtext:=bytes.Repeat([]byte{byte(padding)},padding) //补齐
	return append(ciphertext,padtext...)  //合并

}
//去码
func PKCS5Unpadding(origData []byte)[]byte  {
	length:=len(origData)  //测密码长度
	unadding:=int(origData[length-1]) //取最后一位
	return origData[:(length-unadding)]  //减去最后一位的位数

}
//3DES 加密
func TripleDesEncrypt(origData []byte,key []byte)[] byte  {
	//3DES密钥长度必须是24位
	block,_:=des.NewTripleDESCipher(key)  //获得密钥块  Triple-&amp;gt;3的意思
	//补码
	origData=PKCS5padding(origData,block.BlockSize())
	//设置加密模式
	blockMode:=cipher.NewCBCEncrypter(block,key[:8]) //固定8
	//创建密文数组,加密
	crypted :=make([]byte,len(origData))
	blockMode.CryptBlocks(crypted,origData)
	return crypted
}
//解密
func TripDesDecrypt(crypted,key[]byte)[]byte  {
		block,_:=des.NewTripleDESCipher(key)  //通过密钥得到密码块
		blockMode:=cipher.NewCBCDecrypter(block,key[:8])  //解密
		origData:=make([]byte,len(crypted))  //创建数组
		blockMode.CryptBlocks(origData,crypted) // 解密
		origData=PKCS5Unpadding(origData)  //去码
		return origData

}
//CBC模式
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;方法调用&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main()  {
	var key = []byte(&quot;123456789012345678901234&quot;) //长度为24byte
var encryptcode=TripleDesEncrypt([]byte(&quot;liujiaow&quot;),key)
var decryptcode=TripDesDecrypt(encryptcode,key)
fmt.Println(base64.StdEncoding.EncodeToString(encryptcode))
fmt.Println(string(decryptcode))
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;输出结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vtTkkOTHUHx2nY5Pu2ObTQ==
liujiaow

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 17 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95DES%E5%92%8C3DES/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95DES%E5%92%8C3DES/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>密码学加密算法</title>
        <description>&lt;h1 id=&quot;go-密码学-加密算法&quot;&gt;go 密码学 加密算法&lt;/h1&gt;

&lt;p&gt;###hash算法加密&lt;/p&gt;

&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;加法Hash；&lt;/li&gt;
  &lt;li&gt;位运算Hash；&lt;/li&gt;
  &lt;li&gt;乘法Hash；&lt;/li&gt;
  &lt;li&gt;除法Hash；&lt;/li&gt;
  &lt;li&gt;查表Hash；&lt;/li&gt;
  &lt;li&gt;混合Hash；&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;hash算法有什么特点&quot;&gt;Hash算法有什么特点&lt;/h2&gt;

&lt;p&gt;一个优秀的 hash 算法，将能实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;正向快速&lt;/strong&gt;：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;逆向困难&lt;/strong&gt;：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;输入敏感&lt;/strong&gt;：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;冲突避免&lt;/strong&gt;：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##MD5
MD5讯息摘要演算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码杂凑函数，可以产生出一个128位元（16位元组）的散列值（hash value），用于确保信息传输完整一致。&lt;strong&gt;不可逆推&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用go语言实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func MyMd5() {   //32位字节
	data:=[]byte(&quot;hello world&quot;)
	s:=fmt.Sprintf(&quot;%x\n&quot;,md5.Sum(data)) //把字符串格式化后返回
	fmt.Println(len(s))
	fmt.Println(s)

	h:=md5.New() //声明md5对象
	h.Write(data)  //把data写入h
	s = hex.EncodeToString(h.Sum(nil)) // 十六进制转字符串
	fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;输出结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5eb63bbbe01eeed093cb22bb8f5acdc3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;sha256加密算法&quot;&gt;###sha256加密算法&lt;/h2&gt;
&lt;p&gt;SHA-256 算法输入报文的最大长度不超过2^64 bit，输入按512-bit 分组进行处理，产生的输出是一个256-bit 的报文摘要。&lt;strong&gt;不可逆推&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;go语言实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func Mysha2561()  {
	sum:=sha256.Sum256([]byte(&quot;hello world&quot;))  //得到长度64字节 256位的密文 (一个字节占4位)
	fmt.Printf(&quot;%x\n&quot;,sum)
	//第二种方法
	h:=sha256.New()
	h.Write([]byte(&quot;hello world&quot;))
	fmt.Printf(&quot;%x\n&quot;,h.Sum(nil))

}
//将文档中的加密
func MyIo()  {  //将文件中的内容做256的加密
f,_:=os.Open(&quot;5.16myHash/text.txt&quot;)
h:=sha256.New()
io.Copy(h,f)//把文件名写到h里
fmt.Printf(&quot;%x\n&quot;,h.Sum(nil))


}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;输出结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5eb63bbbe01eeed093cb22bb8f5acdc3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###ripemd160 加密算法&lt;/p&gt;

&lt;p&gt;哈希值的输出值一般是&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;进制的字符串。而&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;进制字符串，每两个字符占一个字节。我们知道，一个字节&lt;code class=&quot;highlighter-rouge&quot;&gt;=8bit&lt;/code&gt;. &lt;strong&gt;不可逆推&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;sha256&lt;/code&gt;为例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;256bit-&amp;gt;64&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;进制字符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;go语言实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//ripemd160 利用hash原理,实现加密  40字节 160位
func MyRipemd160(){
	hasher:=ripemd160.New() //实例化
	hasher.Write([]byte(&quot;hello world&quot;))  //把[]byte类型的字符串类型 写入到加密文件里
	hashString:=fmt.Sprintf(&quot;%x&quot;,hasher.Sum(nil))  //转成16进制字符串
	fmt.Printf(hashString)


}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;输出结果&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5eb63bbbe01eeed093cb22bb8f5acdc3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 17 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%951/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/17/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%951/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>mac 创建公钥和私钥 非对称加密和3DES</title>
        <description>&lt;h1 id=&quot;mac-创建公钥和私钥-非对称加密&quot;&gt;mac 创建公钥和私钥 非对称加密&lt;/h1&gt;
&lt;p&gt;openssl工具 非对称加密&lt;/p&gt;

&lt;p&gt;mac 打开控制台 (产生公钥和私钥)
打开openssl工具&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;openssl 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建私钥&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;genrsa -out rsa_private_key.pem 2048
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这行命令为设置私钥为PKCS8格式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;产生公钥&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;产生 rsa_public_key.pem 公钥
产生rsa_private_key.pem 私钥&lt;/p&gt;

</description>
        <pubDate>Thu, 17 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/17/mac-%E5%88%9B%E5%BB%BA%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/17/mac-%E5%88%9B%E5%BB%BA%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</guid>
        
        <category>密码学</category>
        
        
      </item>
    
      <item>
        <title>hash散列和链表 </title>
        <description>&lt;h2 id=&quot;go语言hash散列和链表&quot;&gt;go语言hash散列和链表&lt;/h2&gt;
&lt;p&gt;通过hash散列算法把输入的值,平均分配的一个长度位16的数组当中去&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//将key转换成数组下标的散列算法
func HashCode(key string) int {
	var index int = 0
	index = int(key[0])
	for k := 0; k &amp;lt; len(key); k++ {
		index *= (1103515245 + int(key[k]))
	}
	index &amp;gt;&amp;gt;= 27
	index &amp;amp;= 16 - 1

	return index
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;每个数组下标,里面存放一个链表头,后面可以无限链接链表,链表分为(地址域&lt;/td&gt;
      &lt;td&gt;数据域),数据域里分为(key&lt;/td&gt;
      &lt;td&gt;value),通过key来找到value.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;创建数组&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package HashMP

import (
	&quot;5.15myHashMap/LinkNodes&quot;
	&quot;fmt&quot;
)



//声明全局数组
var bultArr [16]*LinkNodes.Node


//初始化数组
func CreatBulet() {
	var arr =[16]*LinkNodes.Node{}

	for i:=0;i&amp;lt;16;i++{
		arr[i]=LinkNodes.CreateHeadNode(&quot;头节点&quot;,&quot;头节点&quot;)  //创建16个链表
	}
	bultArr=arr


}


//将key转换成数组下标的散列算法
func HashCode(key string) int {
	var index int = 0
	index = int(key[0])
	for k := 0; k &amp;lt; len(key); k++ {
		index *= (1103515245 + int(key[k]))
	}
	index &amp;gt;&amp;gt;= 27
	index &amp;amp;= 16 - 1

	return index
}
//向数组中添加键值对
func AddkeyValue(k string,v string) {
	//计算键所对应的木桶下标
	var pos = HashCode(k)

	var head *LinkNodes.Node= bultArr[pos]  //获得木桶数组中的 头节点
	LinkNodes.AddNode(k,v,head) //向指定下标的头节点添加节点
}

//获取数据
func GetvalueByKey(k string)string  {
	var pos = HashCode(k)
	//通过散列因子得到数组下标 通过下标找到对应头节点
	var head *LinkNodes.Node=bultArr[pos]
	//通过头节点 遍历链表
	LinkNodes.ShowNodes(head)
	//查找对应下标下的链表 判断key与节点中的key一致时打印
	for {
		if head.Data.K==k{
			fmt.Println(head.Data.V)
			break
		}else {
			head=head.NextNode
			if head.NextNode== nil{

			}
		}
	}
	return &quot;&quot;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;创建链表&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package LinkNodes

import &quot;fmt&quot;

//用结构体作为数据域的类型
type DM struct {
	K string
	V string
}


//声明全局变量,保存头节点
var head *Node //头节点地址
var curr *Node //当前节点地址

type Node struct {//一个链表  声明节点类型
	//数据域
	Data DM
	//地址域  指向下一个节点
	NextNode *Node
}

//创建头节点

func CreateHeadNode(k string ,v string) *Node { //创建节点
	var node *Node = new(Node) //创建
	node.Data.K = k //设置数据域结构体中的键值对
	node.Data.V = v
	//设置地址域
	node.NextNode = nil        //下一个节点的地址
	//保存头节点
	head = node  //创建的是节点 赋值给头
	curr = node  //创建的节点 给当前

	return node

}

//在指定的节点(curr)后面添加新节点
func AddNode(k string,v string, currHead *Node) *Node {  //先用局部变量的 curr
	var newNode *Node = new(Node)
	newNode.Data.K = k    //新节点数据
	newNode.Data.V = v
	newNode.NextNode = nil // 下一个节点的地址
	//挂接节点
	currHead.NextNode = newNode //当前节点的下一个节点==新创建的节点
	currHead = newNode          //curr 等于新创建的节点 =新的节点???

	return newNode

}

//在指定节点遍历链表
func ShowNodes(n * Node) {
	var node =n  //从头开始
	for {

		if node.NextNode==nil{  //退出条件 下一个节点的 地址域==nil
			fmt.Println(node.Data)  //打印该节点的数据
			break
		}else {
			fmt.Println(node.Data)
			node = node.NextNode  //该节点等于下一个节点
		}

	}
}

//计算节点的个数

func Nodecnt() int {
	n := 1
	i := head  //从头开始
	for {
		if i.NextNode == nil {
			break
		}
		n++
		i = i.NextNode  //该节点等于下一个节点
	}
	return n
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可以通过链表的Next.Node来链接链表&lt;/p&gt;

</description>
        <pubDate>Thu, 17 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/17/hash%E6%95%A3%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/17/hash%E6%95%A3%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8/</guid>
        
        <category>hash</category>
        
        
      </item>
    
      <item>
        <title>Nebulas包调用</title>
        <description>&lt;p&gt;#星云链环境搭建mac版&lt;/p&gt;

&lt;h2 id=&quot;golang环境搭建&quot;&gt;Golang环境搭建&lt;/h2&gt;
&lt;p&gt;Components	Version	Description
Golang	&amp;gt;= 1.9.2	The Go Programming Language
我们会分别介绍Mac OSX和Linux两种系统下golang环境的搭建。&lt;/p&gt;

&lt;p&gt;Mac OSX
在Mac OSX里，我们推荐使用Homebrew来安装Golang.&lt;/p&gt;

&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;brew install go&lt;/p&gt;

&lt;h2 id=&quot;配置环境变量&quot;&gt;配置环境变量&lt;/h2&gt;
&lt;p&gt;export GOPATH=/path/to/workspace
提示: 在golang的开发中，GOPATH是必须的，它指定了我们使用golang开发的工作空间。所有的源码都应放在GOPATH之下。
编译星云链
下载源码
可以使用如下指令直接下载最新版本的星云链源码。&lt;/p&gt;

&lt;h2 id=&quot;进入工作目录&quot;&gt;进入工作目录&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;mkdir -p $GOPATH/src/github.com/nebulasio&lt;/strong&gt;
&lt;strong&gt;cd $GOPATH/src/github.com/nebulasio&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;下载源码&quot;&gt;下载源码&lt;/h2&gt;
&lt;p&gt;git clone https://github.com/nebulasio/go-nebulas.git&lt;/p&gt;

&lt;h2 id=&quot;进入项目目录&quot;&gt;进入项目目录&lt;/h2&gt;
&lt;p&gt;cd go-nebulas&lt;/p&gt;

&lt;h2 id=&quot;切换到最稳定的master分支&quot;&gt;切换到最稳定的master分支&lt;/h2&gt;
&lt;p&gt;git checkout master&lt;/p&gt;

&lt;p&gt;##安装rocksdb依赖库
同样我们会介绍如何在MAC OSX和Linux正确安装RocksDB。&lt;/p&gt;

&lt;p&gt;Mac OSX
可以直接通过Homebrew安装，运行&lt;/p&gt;

&lt;p&gt;命令brew install rocksdb
##安装Go依赖库
在Go-Nebulas中，Go的三方库都通过Dep来做管理。&lt;/p&gt;

&lt;p&gt;Components	Version	Description
Dep	&amp;gt;= 0.3.1	Dep is a dependency management tool for Go.&lt;/p&gt;

&lt;p&gt;##安装Dep工具
我们同样分别介绍Mac OSX和Linux下Dep的安装方法。&lt;/p&gt;

&lt;p&gt;Mac OSX
通过Homebrew直接安装并升级Dep
安装命令
brew install dep
brew upgrade dep&lt;/p&gt;

&lt;p&gt;##下载Go三方库
我们切换到Go-Nebulas项目根目录，然后使用Dep来下载三方库。&lt;/p&gt;

&lt;p&gt;cd $GOPATH/src/github.com/nebulasio/go-nebulas
make dep
提示: make dep将会下载很多依赖库。在部分地区，这个过程可能比较耗时。所以，我们提供了依赖库的压缩包vendor.tar.gz。可以使用下列指令通过压缩包来安装GO依赖库。&lt;/p&gt;

&lt;p&gt;下载命令
wget http://ory7cn4fx.bkt.clouddn.com/vendor.tar.gz
切换到文件夹
cd $GOPATH/src/github.com/nebulasio/go-nebulas
解压缩
tar zxf vendor.tar.gz&lt;/p&gt;

&lt;p&gt;##安装Chrome V8依赖库
星云虚拟机目前依赖于Chrome的V8引擎，为了大家使用方便，我们已经为Mac OSX和Linux编译好了V8的动态库。运行如下指令就可以完成安装。&lt;/p&gt;

&lt;p&gt;切换文件夹
cd $GOPATH/src/github.com/nebulasio/go-nebulas
安装v8
make deploy-v8&lt;/p&gt;

&lt;p&gt;##编译可执行文件
完成所有上述依赖库的安装后，现在我们可以进入Go-Nebulas根目录编译星云链的可执行文件了。&lt;/p&gt;

&lt;p&gt;切换文件夹
cd $GOPATH/src/github.com/nebulasio/go-nebulas
编译文件
make build&lt;/p&gt;

</description>
        <pubDate>Tue, 15 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/15/%E6%98%9F%E4%BA%91%E9%93%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/15/%E6%98%9F%E4%BA%91%E9%93%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/</guid>
        
        <category>星云链</category>
        
        
      </item>
    
  </channel>
</rss>
