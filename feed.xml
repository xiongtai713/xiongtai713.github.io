<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘蛟区块链博客</title>
    <description>区块链工程师</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 21 Jul 2018 14:57:53 +0800</pubDate>
    <lastBuildDate>Sat, 21 Jul 2018 14:57:53 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>fabric链码</title>
        <description>&lt;h1 id=&quot;链码的编写和调用&quot;&gt;链码的编写和调用&lt;/h1&gt;

&lt;p&gt;##链码接口与结构&lt;/p&gt;

&lt;h3 id=&quot;依赖包&quot;&gt;依赖包&lt;/h3&gt;

&lt;p&gt;链码实现需要引入如下依赖包&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;“github.com/hyperledger/fabric/core/chaincode/shim”&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;shim包提供了链码与账本交互的中间层&lt;/li&gt;
      &lt;li&gt;链码通过shim.ChaincodeStub提供的方法来读取和修改账本状态&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“github.com/hyperledger/fabric/protos/peer”&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;peer.Response: 响应信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###链码接口&lt;/p&gt;

&lt;p&gt;每个链码都需要实现chaincode接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Chaincode interface{
	Init(stub ChaincodeStubInterface) peer.Response
	Invoke(stub ChaincodeStubInterface) peer.Response
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;init与invoke方法&quot;&gt;Init与Invoke方法&lt;/h3&gt;

&lt;p&gt;编写链码, 关键是实现Init与Invoke两个方法&lt;/p&gt;

&lt;p&gt;Init方法在链码部署或升级时被调用, 完成初始化工作&lt;/p&gt;

&lt;p&gt;对数据进行操作时, Invoke方法被调用, 因此响应调用或查询的业务逻辑都需要在此方法中实现&lt;/p&gt;

&lt;p&gt;###必要结构&lt;/p&gt;

&lt;p&gt;一个链码的必要结构如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

//引入必要的包
import(
	&quot;fmt&quot;
	
	&quot;github.com/hyperledger/fabric/core/chaincode/shim&quot;
	&quot;github.com/hyperledger/fabric/protos/peer&quot;
)

//声明一个结构体
type SimpleChaincode struct {
    
}

//为结构体添加Init方法
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) peer.Response{
  //在该方法中实现链码初始化或升级时的处理逻辑
  //编写时可灵活使用stub中的API
}

//为结构体添加Invoke方法
func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response{
  //在该方法中实现链码运行中被调用或查询时的处理逻辑
  //编写时可灵活使用stub中的API
}

//主函数，需要调用shim.Start（ ）方法
func main() {
  err := shim.Start(new(SimpleChaincode))
  if err != nil {
     fmt.Printf(&quot;Error starting Simple chaincode: %s&quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##链码API&lt;/p&gt;

&lt;h3 id=&quot;账本状态交互api&quot;&gt;账本状态交互API&lt;/h3&gt;

&lt;p&gt;链码需要将数据记录在分布式账本中.需要记录的数据称为状态, 以K-V对的形式存储&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;账本状态交互API&lt;/strong&gt;可以对账本状态进行操作&lt;/p&gt;

&lt;p&gt;GetState(key string)  ([]byte,  error)  通过Key来返回数组的特定值&lt;/p&gt;

&lt;p&gt;PutState(key string, value []byte)  error	账本中写入特定的键和值&lt;/p&gt;

&lt;p&gt;DelState(key string)  error		从账本中移除指定的键和值&lt;/p&gt;

&lt;p&gt;GetStateByRange(startKey, endKey string)  (StateQueryIteratorInterface, error)	根据指定的范围内的健值&lt;/p&gt;

&lt;p&gt;GetHistoryForKey(key string)  (HistoryQueryIteratorInterface, error)	返回指定健的所有历史值&lt;/p&gt;

&lt;p&gt;GetQueryResult(query string)  (StateQueryIteratorInterface, error)	对(支持富查询功能的)状态数据库进行富查询&lt;/p&gt;

&lt;h3 id=&quot;交易信息相关api&quot;&gt;交易信息相关API&lt;/h3&gt;

&lt;p&gt;GetTxID()  string		返回交易提案中指定的交易ID&lt;/p&gt;

&lt;p&gt;GetTxTimestamp()  (*timestamp.Timestamp, error)	返回交易创建的时间戳，这个时间戳是peer收到交易的当前时间&lt;/p&gt;

&lt;p&gt;GetBinding()  ([]byte, error)		返回交易的binding信息&lt;/p&gt;

&lt;p&gt;GetSignedProposal()  (*pb.SignedProposal, error)	返回与交易提案相关的所有数据&lt;/p&gt;

&lt;p&gt;GetCreator()  ([]byte, error)	返回该交易的提交者的身份信息&lt;/p&gt;

&lt;p&gt;GetTransient() (map[string][]byte, error)		返回交易中不会被写至账本中的一些临时信息&lt;/p&gt;

&lt;h3 id=&quot;参数api&quot;&gt;参数API&lt;/h3&gt;

&lt;p&gt;GetArgs()  [][]byte		返回调用链码时交易提案中指定的参数&lt;/p&gt;

&lt;p&gt;GetArgsSlice()  ([]byte, error)	返回调用链码时交易提案中指定的参数&lt;/p&gt;

&lt;p&gt;GetFunctionAndParameters()  (function string, params []string)	返回调用链码时交易提案中指定的被调用的函数名称及其参数&lt;/p&gt;

&lt;p&gt;GetStringArgs() []string	返回调用链码时指定的参数&lt;/p&gt;

&lt;p&gt;-c ‘{“Args”:[“fn”, “param1”, “param2”, “paramN”]}’&lt;/p&gt;

&lt;h2 id=&quot;示例helloworld&quot;&gt;示例(HelloWorld)&lt;/h2&gt;

&lt;h3 id=&quot;init方法&quot;&gt;Init方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;获取参数并判断参数长度是否为2
    &lt;ul&gt;
      &lt;li&gt;参数: Key, Value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;调用PutState方法将状态写入账本中&lt;/li&gt;
  &lt;li&gt;如果有错误, 则返回&lt;/li&gt;
  &lt;li&gt;打印输出提示信息&lt;/li&gt;
  &lt;li&gt;返回成功&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;###Invoke方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取参数并判断长度是否为1&lt;/li&gt;
  &lt;li&gt;利用第1个参数获取对应状态GetState(key)&lt;/li&gt;
  &lt;li&gt;如果有错误则返回&lt;/li&gt;
  &lt;li&gt;如果返回值为空则返回错误&lt;/li&gt;
  &lt;li&gt;返回成功状态&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/21/%E9%93%BE%E7%A0%81%E7%9A%84%E7%BC%96%E5%86%99/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/21/%E9%93%BE%E7%A0%81%E7%9A%84%E7%BC%96%E5%86%99/</guid>
        
        <category>fabric</category>
        
        
      </item>
    
      <item>
        <title>fabric链码实例</title>
        <description>&lt;h1 id=&quot;链码api的实例&quot;&gt;链码API的实例&lt;/h1&gt;
&lt;p&gt;把数据存储在fabric网络中 
PutState&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//-c '{&quot;Args&quot;:[&quot;add&quot;,&quot;姓名&quot;,&quot;ID&quot;,&quot;医院名称&quot;]}'
func add(stub shim.ChaincodeStubInterface,args []string)peer.Response  {
	if len(args)!=3{
		return shim.Error(&quot;错误&quot;)
	}
	person:=Person{
		Name:args[0],
		ID:args[1],
		Time:time.Now().String(),
		Hospital:Hospital{args[2],&quot;北京&quot;,&quot;123456789&quot;},
	}

	p, _ := json.Marshal(person)

	stub.PutState(person.ID,p)

	return shim.Success(nil) //保存完毕

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过k去fabric网络中查找数据
GetState&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func GetId(stub shim.ChaincodeStubInterface,args []string) Person {
	var p Person
	state, _ := stub.GetState(args[0])
	json.Unmarshal(state,&amp;amp;p)
	return p

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过k去fabric网络中查找历史数据
GetHistoryForKey&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//-c '{&quot;Args&quot;:[&quot;his&quot;,&quot;ID&quot;]}'
func histories(stub shim.ChaincodeStubInterface,args []string)peer.Response  {
		if len(args)!=1{
			return shim.Error(&quot;错误&quot;)
		}
	p := GetId(stub, args)  //通过id去 反json取出结构体
	his, _ := stub.GetHistoryForKey(p.ID)
	var h HistoryItem
	var hd []HistoryItem
	var peson Person
	defer his.Close()
	for his.HasNext(){
		hisDate, _ := his.Next()  //取出元素
		h.Txid=hisDate.TxId  //交易序号
		json.Unmarshal(hisDate.Value,&amp;amp;peson) //取出v反json
		h.Person=peson   //存到队里
		hd=append(hd,h)  //合并到一起
	}
	p.HistoryItem=hd  //存到病人里
	bytes, _ := json.Marshal(p) //json化
return 	shim.Success(bytes)

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建组合键,可以通过储存在网络中的k和另一个参数(比如用户名)组合,可以先通过查找该用户名对应的所有k,在把这些k从fabric网络中取出,
CreateCompositeKey(组合键类型,组合键(参数1,参数2))添加组合键
PutState()储存组合键
compositeKey,err:=GetStateByPartialCompositeKey(组合键类型,组合键(参数)) 提取组合键
compositeKey.HasNext() 迭代组合键
SplitCompositeKey() 拆分组合键 可以取出组合键的另一半,通过另一半进行数据查询
###保存组合键&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//创建组合键 持票人id和票据号码
	//存是用票据号码储存,查询的时候要先确定持票人所有的票据id全部找出,在通过id去找出每一张票据
	createCompositeKey, err := stub.CreateCompositeKey(IndexName, []string{bill.HoldrCmID, bill.BillInfoID})
	if err != nil {
		return shim.Error(&quot;组合键失败&quot;)
	}
	//把组合键存到fabric
	err = stub.PutState(createCompositeKey, []byte(&quot;组合键&quot;))
	if err != nil {
		return shim.Error(&quot;组合键存储失败&quot;)
	}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###提取组合键
提取后append到切片里,以json的方式返回ke’hu’d&lt;/p&gt;

&lt;p&gt;```
//提取组合键 `											组合键类型     参数 可以是k(持票人)或者是v(票据id)
	var bills = []Bill{}                                                                     //但是如果是用票据id查找组合键的话,有可能查到被的持票人的组合键
	compositeKey, err := stub.GetStateByPartialCompositeKey(IndexName, []string{args[0]}) //所以这里的args是持票人id 也就是登录用户
	if err != nil {
		return shim.Error(“提取组合键失败”)
	}
	defer compositeKey.Close()
	//迭代组合键
	for compositeKey.HasNext() {
		kv, _ := compositeKey.Next()
		//分割组合键 得到该登录用户(持票人的所有票据id)
		_, value, _ := stub.SplitCompositeKey(kv.Key)
		//通过id查询票据
		bill, b := t.getBill(stub, value[1]) //[0]是持票人id [1]票据id
		if !b{
			return shim.Error(“没有查到该持票人的票据”)
		}
		bills=append(bills,bill)
	}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/21/%E9%93%BE%E7%A0%81API%E7%9A%84%E5%AE%9E%E4%BE%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/21/%E9%93%BE%E7%A0%81API%E7%9A%84%E5%AE%9E%E4%BE%8B/</guid>
        
        <category>fabric</category>
        
        
      </item>
    
      <item>
        <title>链码API</title>
        <description>&lt;h1 id=&quot;链码api&quot;&gt;链码API&lt;/h1&gt;

&lt;h3 id=&quot;账本状态交互api&quot;&gt;账本状态交互API&lt;/h3&gt;

&lt;p&gt;链码需要将数据记录在分布式账本中.需要记录的数据称为状态, 以K-V对的形式存储&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;账本状态交互API&lt;/strong&gt;可以对账本状态进行操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GetState(key string)  ([]byte,  error)  通过Key来返回数组的特定值

PutState(key string, value []byte)  error	账本中写入特定的键和值

DelState(key string)  error		从账本中移除指定的键和值

GetStateByRange(startKey, endKey string)  (StateQueryIteratorInterface, error)	根据指定的范围内的健值

GetHistoryForKey(key string)  (HistoryQueryIteratorInterface, error)	返回指定健的所有历史值

GetQueryResult(query string)  (StateQueryIteratorInterface, error)	对(支持富查询功能的)状态数据库进行富查询
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;交易信息相关api&quot;&gt;交易信息相关API&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GetTxID()  string		返回交易提案中指定的交易ID

GetTxTimestamp()  (*timestamp.Timestamp, error)	返回交易创建的时间戳，这个时间戳是peer收到交易的当前时间

GetBinding()  ([]byte, error)		返回交易的binding信息

GetSignedProposal()  (*pb.SignedProposal, error)	返回与交易提案相关的所有数据

GetCreator()  ([]byte, error)	返回该交易的提交者的身份信息

GetTransient() (map\[string][]byte, error)		返回交易中不会被写至账本中的一些临时信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;参数api&quot;&gt;参数API&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GetArgs()  \[][]byte		返回调用链码时交易提案中指定的参数

GetArgsSlice()  ([]byte, error)	返回调用链码时交易提案中指定的参数

GetFunctionAndParameters()  (function string, params []string)	返回调用链码时交易提案中指定的被调用的函数名称及其参数

GetStringArgs() []string	返回调用链码时指定的参数

-c '{&quot;Args&quot;:[&quot;fn&quot;, &quot;param1&quot;, &quot;param2&quot;, &quot;paramN&quot;]}'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#链码调用&lt;/p&gt;

&lt;p&gt;1.先进入chaincode-docker-devmode文件夹下&lt;/p&gt;

&lt;p&gt;cd ~/hyfa/fabric-samples/chaincode-docker-devmode/&lt;/p&gt;

&lt;p&gt;2.在这个文件夹下启动网路&lt;/p&gt;

&lt;p&gt;sudo docker-compose -f docker-compose-simple.yaml up -d&lt;/p&gt;

&lt;p&gt;3.启动网路后进入cli客户端&lt;/p&gt;

&lt;p&gt;sudo docker exec -it chaincode bash&lt;/p&gt;

&lt;p&gt;4.编译要测试的链码&lt;/p&gt;

&lt;p&gt;4.1切换到要编译的链码文件夹 
root@858726aed16e:/opt/gopath/src/chaincode# cd sacc&lt;/p&gt;

&lt;p&gt;运行编译的链码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;进入开发模式下的cli
开启新终端2进入文件夹
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/hyfa/fabric-samples/chaincode-docker-devmode/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker exec -it cli bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装链码到节点
&lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实例化链码到通道
&lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode instantiate -n mycc -v 0 -c '{&quot;Args&quot;:[&quot;a&quot;,&quot;10&quot;]}' -C myc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;更新链码
    打开新终端2进入cli节点
    &lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/hyfa/fabric-samples/chaincode-docker-devmode/&lt;/code&gt;
    &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker exec -it cli bash&lt;/code&gt;
    安装链码(注意版本号要更新)
    &lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 1&lt;/code&gt;
    更新链码(原来是实例化)
    &lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode upgrade -n mycc -v 1 -c '{&quot;Args&quot;:[&quot;a&quot;, &quot;100&quot;]}' -C myc&lt;/code&gt;
查询链码
    &lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode query -n mycc -c '{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}' -C myc&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   query 或者invoke 都是小写 自动调用Invoke方法   {里的query是方法名称}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/21/%E9%93%BE%E7%A0%81API/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/21/%E9%93%BE%E7%A0%81API/</guid>
        
        <category>fabric</category>
        
        
      </item>
    
      <item>
        <title>fabric-cli节点操作</title>
        <description>&lt;h1 id=&quot;操作cli节点&quot;&gt;操作cli节点&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;自动生成组织结构
 ./byfn.sh -m generate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;启动网路
docker-compose -f docker-compose-cli.yaml up -d
关闭网路
docker-compose -f docker-compose-cli.yaml down
进入cli操作节点
docker exec -it cli bash
退出cli容器
exit

列出当前节点已加入的通道
		peer channel list
	在CLI容器中查看当前操作的是哪个节点
		echo $CORE_PEER_ADDRESS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##进入cli容器
1.建应用通道
在节点中创建通道,指定orderer地址,开启tls验证,开启ca证书验证(给tls验证使用)提高证书地址(在节点文件夹下,挂载后重命名为crypto)
_sk是私钥文件 tlsca是证书文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; peer channel create -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -c mychannel -f ./channel-artifacts/channel.tx     
    
    电脑自动命令
    peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

    

    -o:指定orderer节点的地址
    -c:指定要创建的应用通道的名称(必须与在创建应用通道交易配置文件时通道名称一致)
    -f:指定创建应用通道时所使用的应用通道交易配置文件
    --tls:开启tls验证 (验证ca证书)
    --cafile:指定TLS_CA证书路径
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;命令执行成功在当前目录下生成一个对应的文件: mychannel.block&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;查看通道配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;../bin/configtxgen -inspectChannelCreateTx ./channel-artifacts/channel.tx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.链接操作
把当前节点加入应用通道中&lt;/p&gt;

&lt;p&gt;peer channel join -b xxxxxx  (在cli里创建好的通道名称.block)
    -b:指定当前节点要加入/链接到应用通道&lt;/p&gt;

&lt;p&gt;3.更新锚节点&lt;/p&gt;

&lt;p&gt;使用Org1的管理员身份更新锚节点配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.更变节点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(同组织msp和ca不用改)
切换为pee1.org1.example.com

CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;   切换组织

CORE_PEER_ADDRESS=peer1.org1.example.com:7051  切换节点

CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
MSP路径

CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt
证书路径
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/21/%E6%93%8D%E4%BD%9Ccli%E8%8A%82%E7%82%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/21/%E6%93%8D%E4%BD%9Ccli%E8%8A%82%E7%82%B9/</guid>
        
        <category>fabric</category>
        
        
      </item>
    
      <item>
        <title>fabric多通道应用</title>
        <description>&lt;h1 id=&quot;多通道调用&quot;&gt;多通道调用&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 首先创建应用通道交易配置文件
2. 创建组织锚节点更新文件
3. 启动网络并进入CLI节点
4. 创建指定的新的应用通道
5. 将节点加入至通道中
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###临时变量 同到名称&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export CHANNEL_NAME=mychannel2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;###创建新通道配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;工具名称 configtxgen&lt;/li&gt;
  &lt;li&gt;通道模板 -profile TwoOrgsChannel  路径在first-network/configtx.yaml中 模板内是哪个组织可以加入通道&lt;/li&gt;
  &lt;li&gt;outputCreateChannelTx(创建新的配置文件) ./channel-artifacts(文件储存在)/channel.tx(储存的文件名称)&lt;/li&gt;
  &lt;li&gt;通道ID -channelID $CHANNEL_NAME (这个名称会保存在channel.tx这个文件里)
###创建通道内的锚节点&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP

$ sudo ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;工具名称 configtxgen&lt;/li&gt;
  &lt;li&gt;通道模板 -profile TwoOrgsChannel&lt;/li&gt;
  &lt;li&gt;outputAnchorPeersUpdate ./channel-artifacts(保存路径)/Org2MSPanchors.tx(储存文件名称)&lt;/li&gt;
  &lt;li&gt;-channelID $CHANNEL_NAME(这个通道id必须跟通道配置的id一样,否则无法加入通道)&lt;/li&gt;
  &lt;li&gt;-asOrg Org2MSP 这个节点是哪个组织的(Org2MSP 是org2组织的)  &lt;strong&gt;?创建锚节点时 Org2MSP 是关键字吗&lt;/strong&gt;(在congfig里有组织名称)
###启动网络&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker-compose -f docker-compose-cli.yaml up -d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;进入cli操作节点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it cli bash
进入cli之后 还要设定临时变量
$ export CHANNEL_NAME=mychannel2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建通道&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;create -o orderer.example.com:7050 (指定orderer节点)&lt;/li&gt;
  &lt;li&gt;-c $CHANNEL_NAME (通道id)&lt;/li&gt;
  &lt;li&gt;-f  ./channel-artifacts/channel.tx (通道配置文件,声明那些组织可以加入本通道)&lt;/li&gt;
  &lt;li&gt;–tls(开启tls验证验证ca证书) –cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem (ca证书地址 证书被包含在组织结构里面了,映射到crypto文件夹里,直接使用orderer节点下的ca证书)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;创建完成后产生.block通道文件
列出当前节点已加入的通道
		peer channel list
	在CLI容器中查看当前操作的是哪个节点
		echo $CORE_PEER_ADDRESS&lt;/p&gt;

&lt;p&gt;###节点加入新创建的通道&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;peer channel join -b mychannel2.block -o orderer:7050
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;加入通道后可以进行查询
如果别的节点要加入通道,进行节点的切换
节点在通道实例化链码的时候,一定注意声明在哪个通道上实例化&lt;/p&gt;

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/21/%E5%A4%9A%E9%80%9A%E9%81%93%E8%B0%83%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/21/%E5%A4%9A%E9%80%9A%E9%81%93%E8%B0%83%E7%94%A8/</guid>
        
        <category>fabric</category>
        
        
      </item>
    
      <item>
        <title>fabric使用开发模式测试链码</title>
        <description>&lt;h1 id=&quot;使用开发模式测试链码&quot;&gt;使用开发模式测试链码&lt;/h1&gt;
&lt;p&gt;给予权限
将当前的登录用户添加到docker组中
		$ sudo usermod -aG docker liu
		添加完成之后要注销&lt;/p&gt;

&lt;p&gt;1.先进入chaincode-docker-devmode文件夹下&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/hyfa/fabric-samples/chaincode-docker-devmode/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.在这个文件夹下启动网路&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker-compose -f docker-compose-simple.yaml up -d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.启动网路后进入cli客户端&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker exec -it chaincode bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4.编译要测试的链码&lt;/p&gt;

&lt;p&gt;4.1切换到要编译的链码文件夹 
` root@858726aed16e:/opt/gopath/src/chaincode#  cd sacc`&lt;/p&gt;

&lt;p&gt;4.2进行编译
在文件夹下编译链码,编译之前要在github下载shim&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;go build&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5.运行编译的链码&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./sacc&lt;/code&gt;
前面是配置文件中的端口(有bug配置文件里是7051)  中间是要启动的链码名称和版本号(版本默认是0) 最后是启动的那个文件&lt;/p&gt;

&lt;p&gt;6.进入开发模式下的cli
开启新终端2进入文件夹
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/hyfa/fabric-samples/chaincode-docker-devmode/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker exec -it cli bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;7.安装链码到节点
&lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;8.实例化链码到通道
&lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode instantiate -n mycc -v 0 -c '{&quot;Args&quot;:[&quot;a&quot;,&quot;10&quot;]}' -C myc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;9.调用链码(进行调用,将 a 的值更改为 20)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;  peer chaincode invoke -n mycc -c '{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;20&quot;]}' -C myc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;10.升级链码
    退出中端1和2,再次进入开发模式
    &lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/hyfa/fabric-samples/chaincode-docker-devmode/&lt;/code&gt;
    &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker exec -it chaincode bash&lt;/code&gt;
     更新链码 从新编译新链码
    &lt;code class=&quot;highlighter-rouge&quot;&gt;cd sacc&lt;/code&gt;
    &lt;code class=&quot;highlighter-rouge&quot;&gt;go build&lt;/code&gt;
    运行编译的链码
    &lt;code class=&quot;highlighter-rouge&quot;&gt;CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:1 ./sacc&lt;/code&gt;
11.更新链码
    打开新终端2进入cli节点
    &lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/hyfa/fabric-samples/chaincode-docker-devmode/&lt;/code&gt;
    &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker exec -it cli bash&lt;/code&gt;
    安装链码(注意版本号要更新)
    &lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode install -p chaincodedev/chaincode/sacc -n mycc -v 1&lt;/code&gt;
    更新链码(原来是实例化)
    &lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode upgrade -n mycc -v 1 -c '{&quot;Args&quot;:[&quot;a&quot;, &quot;100&quot;]}' -C myc&lt;/code&gt;
12.查询链码
    &lt;code class=&quot;highlighter-rouge&quot;&gt;peer chaincode query -n mycc -c '{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}' -C myc&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   query 或者invoke 都是小写 自动调用Invoke方法   {里的query是方法名称}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/21/%E4%BD%BF%E7%94%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%E9%93%BE%E7%A0%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/21/%E4%BD%BF%E7%94%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%E9%93%BE%E7%A0%81/</guid>
        
        <category>fabric</category>
        
        
      </item>
    
      <item>
        <title>fabric自动启动和手动启动</title>
        <description>&lt;h1 id=&quot;fabric开发流程自动模式和手动模式&quot;&gt;fabric开发流程(自动模式和手动模式)&lt;/h1&gt;
&lt;p&gt;1.部署区块链网路,把组织添加到应用通道里,只要在通一通道里,跨联盟也可用通过oderer节点进行交易&lt;/p&gt;

&lt;p&gt;2.部署智能合约(链码),通过调用智能合约,来触发合约内容&lt;/p&gt;

&lt;p&gt;###fabric网路启动过程
		1. 生成组织结构及身份证书
		2. 生成Orderer的初始区块
		3. 生成应用通道交易配置文件
		4. 生成各组织的锚节点更新文件
		5. 启动网络
		6. 进入CLI容器
		7. 创建应用通道
		8. 将当前节点加入到指定的通道中
		9. 安装链码
		10. 实例化链码
		11. 查询/调用链码&lt;/p&gt;

&lt;p&gt;##自动模式
###生成组织结构及身份证书
&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo ./byfn.sh generate&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cryptogen generate –config=./crypto-config.yaml
生成两个组织
org1.example.com(组织1)
org2.example.com(组织2)&lt;/li&gt;
  &lt;li&gt;res=0&lt;/li&gt;
  &lt;li&gt;set +x&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成区块&lt;/p&gt;

&lt;p&gt;Generating Orderer Genesis block&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;生成相应的组织结构及身份证书
     &lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo ./byfn.sh generate&lt;/code&gt;
         – 生成组织结构及身份证书(保存在当前目录的crypto-config目录)
         – 生成Orderer初始区块配置文件(保存在当前目录的chanel-artifacts目录下)
         – 生成应用通道交易配置文件(保存在当前目录的chanel-artifacts目录下)
         – 组织中锚节点更新配置文件(保存在当前目录的chanel-artifacts目录下)
             – 检测当前应用通道中新加入的节点
             – 跨组织的数据交换&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ configtxgen -profile TwoOrgsOrdererGenesis(生成区块模板) -outputBlock ./channel-artifacts/genesis.block(保存目录)   

通道配置交易
Generating channel configuration transaction 'channel.tx'
+ configtxgen -profile TwoOrgsChannel (生成模板名称)-outputCreateChannelTx ./channel-artifacts(保存在哪个目录下面)/channel.tx -channelID mychannel(默认通道名称)


锚节点的更新配置文件 组织1
Generating anchor peer update for Org1MSP
+ configtxgen -profile TwoOrgsChannel(模板名称) -outputAnchorPeersUpdate ./channel-artifacts(生成的更新文件的保存路径)/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP(组织默认名称要和通道一致)

锚节点的更新配置文件 组织2
Generating anchor peer update for Org2MSP
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##启动网路
sudo ./byfn.sh -m up&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进入CLI容器后, 默认节点为: peer0.org1.example.com&lt;/strong&gt;(控制节点容器)
通过配置文件把节点信息挂载在cli上,在cli上操作各个组织节点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tls: 数据传输协议, 保证数据在传输过程中的安全性及完整性
–tls: 只要指定开启tls, 值为true&lt;/strong&gt;
验证数据完整性
验证数据安全性(是否被窃听过)&lt;/p&gt;

&lt;p&gt;ca fabric自带生成证书的&lt;/p&gt;

&lt;p&gt;msp 身份证明  证书和密钥
成员管理&lt;/p&gt;

&lt;p&gt;1.创建通道&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ peer channel create -o orderer.example.com:7050(orderer地址) -c mychannel(通道名称) -f ./channel-artifacts/channel.tx(配置文件所在路径) --tls(数据传输协议) true(开启tsl验证) --cafile(证书文件) /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem(ca 证书节点所在路径)
2.把节点加入到通道
===================== peer1.org2 joined channel 'mychannel' =====================
切换身份后 所有节点都要加入通道
Having all peers join the channel...
+ peer channel join -b mychannel.block(选择哪个通道)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.检测当前应用通道,如果有新节点加入,进行验证,然后进行广播
切换身份,更新不同的节点加入通道&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
+ peer channel update(更新锚节点) -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem(证书路径)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.安装链码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ peer chaincode install (安装链码)-n mycc -v 1.0 -l golang(语言选择) -p github.com/chaincode/chaincode_example02/go/(链码的所在路径)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.链码实例化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Instantiating chaincode on peer0.org2...
+ peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel (通道名称)-n mycc(链码名称) -l golang -v 1.0 -c '{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]}'(初始参数) -P 'AND (and是所有) (OR是其中一个)  ('\''Org1MSP.peer'\'','\''Org2MSP.peer'\'')'(链码策略 指定背书节点,谁进行签名)
org1和oeg2 下面所有节点都要签名

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.查询链码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Querying chaincode on peer0.org1...
+ peer chaincode query -C mychannel (在哪个通道查询)-n mycc -c '{&quot;Args&quot;:[&quot;query&quot;(执行查询/函数名称),&quot;a&quot;(参数)]}')
查询后得到到数值是 100

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.链码调用
只有两种方法
query:查询
invoke:执行事务
链码必须在所有的指定节点上安装,安装成功后,要对链码进行实例化,实例化只需要执行一次即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sending invoke transaction on peer0.org1 peer0.org2...(两个节点)
+ peer chaincode invoke -o orderer.example.com:7050 (oderder地址)--tls true(开启节点验证) --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel(通道名称) -n mycc(链码名称) --peerAddresses peer0.org1.example.com:7051(指定节点) --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt(第一个节点ca 证书路径) --peerAddresses peer0.org2.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt(第二个节点ca证书路径) -c '{&quot;Args&quot;:
[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}'

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6.最后一定记住关闭网路
sudo ./byfn.sh -m down
    –同时删除产生的&lt;/p&gt;

&lt;p&gt;#手动启动网路
../bin/cryptgen
##1.生成组织结构和身份证书
命令
配置文件 first-network/crypto-config.yaml
 showtemplate节点查看模板信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-可以通过修改first-network/cryptp-config.yaml进行修改节点信息```&quot;&gt;        新增组织一定注意缩进 前面要有两个空格

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Name: Orderer  名称(前面两个空格)
    Domain: example.com  域名&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Name: Org1
Domain: org1.example.com
EnableNodeOUs: false

Name: Org2 组织名字
Domain: org2.example.com  域名
EnableNodeOUs: false
Template:
  Count: 2  节点数量(前面两个空格)
Users:
  Count: 1  新增管理用户数量
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;生成组织和节点
```../bin/cryptgen generate --config=./crypto-config.yaml```
需要在first-network里执行要不找不到crypto-config.yaml
生成之后first-network文件夹内

##生成oderer初始区块配置文件
-- first-network.configtx.yaml  配置文件
使用configtxgen
``$  export CHANNEL_NAME=mychannel 定义临时变量 ``

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;$ sudo ../bin/configtxgen -profile TwoOrgsOrdererGenesis -channelID $CHANNEL_NAME -outputBlock ./channel-artifacts/genesis.block&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
channeID (通道名称)-少参数
TwoOrgsOrdererGenesis(模板名称)
生成应用通道配置文件时
配置文件中会指定
组织 名称和ID
msp地址
锚节点是哪个节点

--help

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;-channelID string  (通道名称)
    	The channel ID to use in the configtx
  -configPath string  (配置路径如果不选,就用默认-可选)
    	The path containing the configuration to use (if set)
  -inspectBlock string(查看指定区块内容)
    	Prints the configuration contained in the block at the specified path
  -inspectChannelCreateTx string(查看指定通道内容)
    	Prints the configuration contained in the transaction at the specified path
  -outputAnchorPeersUpdate string(锚节点配置节点)
    	Creates an config update to update an anchor peer (works only with the default channel creation, and only for the first update)
  -outputBlock string(生成初始区块的保存路径)
    	The path to write the genesis block to (if set)
  -outputCreateChannelTx string (应用通道保存路径)
    	The path to write a channel creation configtx to (if set)
  -printOrg string (输出的组织)
    	Prints the definition of an organization as JSON. (useful for adding an org to a channel manually)
  -profile string (指定模板名称)
    	The profile from configtx.yaml to use for generation. (default “SampleInsecureSolo”)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 
3.生成应用通道交易配置文件
-- -- first-network.configtx.yaml  配置文件

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;$ sudo ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
-profile TwoOrgsChannel(模板名称)

4.生成锚节点更新配置文件 添加到通道里
每个组织要生成一个锚节点
-- first-network.configtx.yaml  配置文件

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;$ sudo ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP&lt;/p&gt;

&lt;p&gt;$ sudo ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
节点发现

设置好的配置文件 可以在 first-network/channel-artifacts文件夹下找到

5.启动网路

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker-compose -f docker-compose-cli.yaml up -d(可以不加-d)(启动一组镜像)
    -f:指定启动网路时所使用的配置文件
        --该配置文件中描述了启动网路时有哪些容器被启动
        --指定容器中所挂载的内容
    -d :再启动过程中不打印详细参数
    启动后根据配置文件会有6个容器  可以通过docker ps来查看
    orderer
    cli  所有节点信息挂载在cli里  (volumes 挂载) 把真机的路径映射到虚拟机中 可以从 first-network/docker-compose-cli.yaml 查看 里面通过找到 docker-compose-base.yam文件,里面是节点信息   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    org1 peer0  锚节点(默认)
    org2 peer0  锚节点(默认)
    org1 peer1
    org2 peer1
    关闭网路
    关闭网路,使用那个文件启动的就用那个文件关闭(这种关闭不会删除配置文件,自动的会删除配置文件)
$ docker-compose -f docker-compose-cli.yaml down
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/21/fabric%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B(%E8%87%AA%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%89%8B%E5%8A%A8%E6%A8%A1%E5%BC%8F)/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/21/fabric%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B(%E8%87%AA%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%89%8B%E5%8A%A8%E6%A8%A1%E5%BC%8F)/</guid>
        
        <category>fabric</category>
        
        
      </item>
    
      <item>
        <title>fabric-ca应用</title>
        <description>&lt;h1 id=&quot;fabric-ca应用&quot;&gt;fabric-ca应用&lt;/h1&gt;
&lt;p&gt;先安装 参照文档5-fabric应用与配置
初始化目录,新建一个文件夹把fabric-ca当做服务器文件夹&lt;/p&gt;

&lt;p&gt;##fabric-ca服务器启动:&lt;/p&gt;

 	1. 使用init进行初始化(只做初始化)
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2. 使用start启动 (初始化和启动同时做)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;初始化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ fabric-ca-server init -b admin:pass
-b admin:pass  指定用户名和密码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;快速启动并初始化一个fabric-ca-server服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ fabric-ca-server start -b admin:pass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;restful-api&quot;&gt;RESTful API&lt;/h3&gt;

&lt;p&gt;在打开的新终端中输入以下命令获取指定CA服务的基本信息.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -X POST -d '{&quot;caname&quot;:&quot;test_ca&quot;}' http://localhost:7054/api/v1/cainfo

curl 指定的路径
-x POST 请求方式POST
-d 请求需要的参数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##服务端命令剖析&lt;/p&gt;

&lt;p&gt;fabric-ca-server命令主要负责启动一个CA服务, 包括init和start两个子命令
以上服务器启动完毕&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;#fabric-ca客服端
注册管理员需要以管理员身份使用CA Client连接到CA Server，并生成相应的文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export PATH=$GOPATH/src/github.com/hyperledger/fabric-ca/bin:$PATH
$ fabric-ca-client enroll -u http://admin:pass@localhost:7054
-u http://admin:pass@localhost:7054 指定用户名:密码@ca服务器地址
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####注册用户&lt;/p&gt;

&lt;p&gt;登记后的用户身份可以采用如下命令来注册一个新的用户:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ fabric-ca-client register --id.name kevin --id.type user --id.affiliation org1.department1 --id.attrs '&quot;hf.Registrar.Roles=peer,user&quot;' --id.attrs 'hf.Revoker=true'
--id.name kevin 用户名
--id.type user 用户角色 (可以在配置文件中找到角色类型)
--id.affiliation org1.department1 (在哪个组织的那个部门)
--id.attrs '&quot;hf.Registrar.Roles=peer,user&quot;' (ID的属性)??
--id.attrs 'hf.Revoker=true'(证书是否可以吊销)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;##登记用户
可以再次使用enroll命令，给kevin这个用户生成msp的私钥和证书&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ fabric-ca-client enroll -u http://kevin:KDwrXkAFENWW@localhost:7054 -M kevinca
kevin:KDwrXkAFENWW (刚才生成的用户名和密码)
-M kevinca(生成的私钥和证书保存在哪个文件夹下 kevinca文件夹名)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可使用tree使用查看&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ tree .fabric-ca-client/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;msp文件夹下是管理员的证书和私钥
 kevinca是刚注册的证书和私钥&lt;/p&gt;

&lt;p&gt;##登记节点&lt;/p&gt;

&lt;p&gt;登记Peer或Orderer节点的操作与登记用户身份类似.  可以通过-M指定本地MSP的根路径来在其下存放证书文件&lt;/p&gt;

&lt;p&gt;#####注册节点:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ fabric-ca-client register --id.name peer0 --id.type peer --id.affiliation org1.department1 --id.secret peer0pw
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#####登记节点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ fabric-ca-client enroll -u http://peer0:peer0pw@localhost:7054 -M peer0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 21 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/21/fabric-ca%E5%BA%94%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/21/fabric-ca%E5%BA%94%E7%94%A8/</guid>
        
        <category>fabric</category>
        
        
      </item>
    
      <item>
        <title>etcd 服务器搭建集群</title>
        <description>&lt;h1 id=&quot;etcd多服务器集群搭建&quot;&gt;etcd多服务器集群搭建&lt;/h1&gt;

&lt;p&gt;下面三台不同的服务器搭建三个节点&lt;/p&gt;

&lt;p&gt;系统：ubuntu16.06 x64&lt;/p&gt;

&lt;p&gt;node1:10.0.151.251&lt;/p&gt;

&lt;p&gt;node2:10.0.151.218&lt;/p&gt;

&lt;p&gt;node3:10.0.151.217&lt;/p&gt;

&lt;h2 id=&quot;1启动节点&quot;&gt;1、启动节点&lt;/h2&gt;

&lt;p&gt;node1启动&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TOKEN=token-01
CLUSTER_STATE=new
NAME_1=machine-1
NAME_2=machine-2
NAME_3=machine-3
HOST_1=10.0.151.251
HOST_2=10.0.151.218
HOST_3=10.0.151.217
CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380

cd $GOPATH/src/github.com/coreos/etcd/
make clean
cd bin
THIS_NAME=${NAME_1}
THIS_IP=${HOST_1}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;node2启动&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TOKEN=token-01
CLUSTER_STATE=new
NAME_1=machine-1
NAME_2=machine-2
NAME_3=machine-3
HOST_1=10.0.151.251
HOST_2=10.0.151.218
HOST_3=10.0.151.217
CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380

cd $GOPATH/src/github.com/coreos/etcd/
make clean
cd bin
THIS_NAME=${NAME_2}
THIS_IP=${HOST_2}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;node3启动&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TOKEN=token-01
CLUSTER_STATE=new
NAME_1=machine-1
NAME_2=machine-2
NAME_3=machine-3
HOST_1=10.0.151.251
HOST_2=10.0.151.218
HOST_3=10.0.151.217
CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380

cd $GOPATH/src/github.com/coreos/etcd/
make clean
cd bin
THIS_NAME=${NAME_3}
THIS_IP=${HOST_3}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;2查询节点&quot;&gt;2、查询节点&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ETCDCTL_API=3
ENDPOINTS=http://10.0.151.251:2379,http://10.0.151.218:2379,http://10.0.151.217:2379
cd $GOPATH/src/github.com/coreos/etcd/bin
./etcdctl --endpoints=$ENDPOINTS member list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;3添加节点&quot;&gt;3、添加节点&lt;/h2&gt;

&lt;p&gt;我又添加了一台服务器10.0.151.208,将这台服务器添加到集群中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ETCDCTL_API=3
ENDPOINTS=http://10.0.151.251:2379,http://10.0.151.218:2379,http://10.0.151.217:2379
cd $GOPATH/src/github.com/coreos/etcd/bin
./etcdctl --endpoints=$ENDPOINTS member add machine-4 --peer-urls=http://10.0.151.208:2380
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;node4启动&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TOKEN=token-01
CLUSTER_STATE=existing
NAME_1=machine-1
NAME_2=machine-2
NAME_3=machine-3
NAME_4=machine-4
HOST_1=10.0.151.251
HOST_2=10.0.151.218
HOST_3=10.0.151.217
HOST_4=10.0.151.208
CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380,${NAME_4}=http://${HOST_4}:2380

cd $GOPATH/src/github.com/coreos/etcd/
make clean
cd bin
THIS_NAME=${NAME_4}
THIS_IP=${HOST_4}

./etcd --data-dir=data.etcd --name ${THIS_NAME} --listen-client-urls http://${THIS_IP}:2379 --advertise-client-urls http://${THIS_IP}:2379 --listen-peer-urls http://${THIS_IP}:2380 --initial-advertise-peer-urls http://${THIS_IP}:2380 --initial-cluster-state ${CLUSTER_STATE} --initial-cluster ${CLUSTER} --initial-cluster-token ${TOKEN}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;4删除节点&quot;&gt;4、删除节点&lt;/h2&gt;

&lt;p&gt;先查询节点&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ETCDCTL_API=3
ENDPOINTS=http://10.0.151.251:2379,http://10.0.151.218:2379,http://10.0.151.217:2379
cd $GOPATH/src/github.com/coreos/etcd/bin
./etcdctl --endpoints=$ENDPOINTS member list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;找到要删除的节点的id，再删除&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd $GOPATH/src/github.com/coreos/etcd/bin
./etcdctl --endpoints=$ENDPOINTS member remove b9057cfdc8ff17ce
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 13 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/13/etcd%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/13/etcd%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</guid>
        
        <category>etcd</category>
        
        
      </item>
    
      <item>
        <title>etcd 多台服务器集群</title>
        <description>&lt;h1 id=&quot;etcd-多台服务器集群&quot;&gt;etcd 多台服务器集群&lt;/h1&gt;

&lt;h2 id=&quot;下载安装-etcd&quot;&gt;下载安装 etcd&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir -p $GOPATH/src/github.com/coreos
$ cd !$
$ git clone https://github.com/coreos/etcd.git
$ cd etcd
$ ./build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;启动服务&quot;&gt;启动服务&lt;/h2&gt;

&lt;p&gt;每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TOKEN=token-01
CLUSTER_STATE=new
NAME_1=machine-1
NAME_2=machine-2
NAME_3=machine-3
HOST_1=192.168.1.126
HOST_2=192.168.1.119
HOST_3=192.168.1.103
CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;machine 1&lt;/strong&gt; 执行如下命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd/bin

# For machine 1
THIS_NAME=${NAME_1}
THIS_IP=${HOST_1}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;machine 2&lt;/strong&gt; 执行如下命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd/bin

# For machine 2
THIS_NAME=${NAME_2}
THIS_IP=${HOST_2}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;machine 3&lt;/strong&gt; 执行如下命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd/bin

# For machine 3
THIS_NAME=${NAME_3}
THIS_IP=${HOST_3}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检测服务器运行是否正常&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd/bin

export ETCDCTL_API=3
HOST_1=192.168.1.126
HOST_2=192.168.1.119
HOST_3=192.168.1.103
ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379

./etcdctl --endpoints=$ENDPOINTS member list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;存储数据&quot;&gt;存储数据&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./etcdctl --endpoints=$ENDPOINTS put foo &quot;Hello World!&quot;

./etcdctl --endpoints=$ENDPOINTS get foo
./etcdctl --endpoints=$ENDPOINTS --write-out=&quot;json&quot; get foo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;根据前缀查询&quot;&gt;根据前缀查询&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./etcdctl --endpoints=$ENDPOINTS put web1 value1
./etcdctl --endpoints=$ENDPOINTS put web2 value2
./etcdctl --endpoints=$ENDPOINTS put web3 value3

./etcdctl --endpoints=$ENDPOINTS get web --prefix

web1
value1
web2
value2
web3
value3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./etcdctl --endpoints=$ENDPOINTS put key myvalue
./etcdctl --endpoints=$ENDPOINTS del key

./etcdctl --endpoints=$ENDPOINTS put k1 value1
./etcdctl --endpoints=$ENDPOINTS put k2 value2
./etcdctl --endpoints=$ENDPOINTS del k --prefix
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;事务写入&quot;&gt;事务写入&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./etcdctl --endpoints=$ENDPOINTS put user1 bad
OK

$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive

compares:
// 输入以下内容，输入结束按 两次回车
value(&quot;user1&quot;) = &quot;bad&quot;      

//如果 user1 = bad，则执行 get user1 
success requests (get, put, del):
get user1

//如果 user1 != bad，则执行 put user1 good
failure requests (get, put, del):
put user1 good

// 运行结果，执行 success
SUCCESS

user1
bad



$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive
compares:
value(&quot;user1&quot;) = &quot;111&quot;  

// 如果 user1 = 111，则执行 get user1 
success requests (get, put, del):
get user1

//如果 user1 != 111，则执行 put user1 2222
failure requests (get, put, del):
put user1 2222

// 运行结果，执行 failure
FAILURE

OK

$ ./etcdctl --endpoints=$ENDPOINTS get user1
user1
2222
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;watch&quot;&gt;watch&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知
./etcdctl --endpoints=$ENDPOINTS watch stock1

// 新打开终端
$ cd $GOPATH/src/github.com/coreos/etcd/bin

export ETCDCTL_API=3
HOST_1=192.168.1.126
HOST_2=192.168.1.119
HOST_3=192.168.1.103
ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379
./etcdctl --endpoints=$ENDPOINTS put stock1 1000

./etcdctl --endpoints=$ENDPOINTS watch stock --prefix

./etcdctl --endpoints=$ENDPOINTS put stock1 10
./etcdctl --endpoints=$ENDPOINTS put stock2 20
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Fri, 13 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/07/13/etcd-%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/13/etcd-%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4/</guid>
        
        <category>etcd</category>
        
        
      </item>
    
  </channel>
</rss>
