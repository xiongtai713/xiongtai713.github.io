<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘蛟区块链博客</title>
    <description>区块链工程师</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 09 Jun 2018 14:51:35 +0800</pubDate>
    <lastBuildDate>Sat, 09 Jun 2018 14:51:35 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>http,socket,RPC,TCP区别</title>
        <description>&lt;h1 id=&quot;有了http为何还有rpc&quot;&gt;有了HTTP为何还有RPC？&lt;/h1&gt;

&lt;p&gt;论复杂度，RPC框架肯定是高于简单的HTTP接口的。但毋庸置疑，HTTP接口由于受限于HTTP协议，需要带HTTP请求头，导致传输起来效率或者说安全性不如RPC。&lt;/p&gt;

&lt;p&gt;下面展示了一个请求头，无用数据过多，响应头类似&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /search/suggest/initial_page/ HTTP/1.1
Host	www.toutiao.com
Content-Type	application/x-www-form-urlencoded
Accept-Encoding	gzip, deflate
Cookie	CNZZDATA1259612802=569328305-1527816505-https%253A%252F%252Fwww.baidu.com%252F%7C1527821905; WEATHER_CITY=%E5%8C%97%E4%BA%AC; __tasessionId=i33ntavtt1527822487203; tt_webid=6561930712081466884; UM_distinctid=163b91509b88ff-0e1ee05ec87bae-3f636c4f-13c680-163b91509b96aa; _ga=GA1.2.195827442.1493809988; sso_login_status=0; tt_webid=6561930712081466884; uuid=&quot;w:b5453e80f63342d1afe07a5d3c3360f9&quot;
Connection	keep-alive
Proxy-Connection	keep-alive
Accept	text/javascript, text/html, application/xml, text/xml, */*
User-Agent	Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1 Safari/605.1.15
Referer	https://www.toutiao.com/
Accept-Language	zh-cn
X-Requested-With	XMLHttpRequest
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;http接口是在接口不多、系统与系统交互较少的情况下；优点就是简单、直接、开发方便。利用现成的http协议进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http 一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。&lt;/p&gt;

&lt;p&gt;HTTP与RPC存在重大不同的是：请求是使用具有标准语义的通用的接口定向到资源的，这些语义能够被中间组件和提供服务的来源机器进行解释。结果是使得一个应用支持分层的转换和间接层，并且独立于消息的来源。&lt;/p&gt;

&lt;p&gt;与之相比较，RPC的机制是根据语言的API来定义的，而不是根据基于网络的应用来定义的。&lt;/p&gt;

&lt;p&gt;事实上，对于http,也可以作为RPC框架的通信层协议和实现。
只不过，对于大部分企业成熟的RPC框架，使用thrift等工具可以实现二进制传输，相比HTTP的文本传输无疑大大提高了传输效率; HTTP通常使用的json，一个需要用户序列化/反序列化，性能和复杂度较高。相比之下，Thrift等工具，使用了成熟的代码生成技术，将通信接口的文件生成了对应语言的代码接口，实现了远程调用接近于本地方法的调用。另外无论是网络传输编码、解码，还是传输内容大小还是网络开销都想比HTTP有较大的优势。&lt;/p&gt;

&lt;p&gt;一般rpc框架包括：服务查找，负载均衡，服务降级、熔断，下游路由配置，数据格式约定，链接维护等几个方面。&lt;/p&gt;

&lt;h1 id=&quot;tcphttp与socket区别&quot;&gt;TCP、HTTP与Socket区别&lt;/h1&gt;

&lt;h3 id=&quot;一tcp连接&quot;&gt;一、TCP连接&lt;/h3&gt;

&lt;p&gt;手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。&lt;/p&gt;

&lt;p&gt;建立起一个TCP连接需要经过“三次握手”：&lt;/p&gt;

&lt;p&gt;第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；&lt;/p&gt;

&lt;p&gt;第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；&lt;/p&gt;

&lt;p&gt;第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。&lt;/p&gt;

&lt;p&gt;握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写 了，就是服务器和客户端交互，最终确定断开）&lt;/p&gt;

&lt;h3 id=&quot;二http连接&quot;&gt;二、HTTP连接&lt;/h3&gt;

&lt;p&gt;HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;http 为短连接：&lt;/strong&gt;客户端发送请求都需要服务器端回送响应。请求结束后，主动释放链接，因此为短连接。要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。&lt;/p&gt;

&lt;p&gt;TCP是底层通讯协议，定义的是数据传输和连接方式的规范
HTTP是应用层协议，定义的是传输数据的内容的规范。
http与tcp不是对等的两种协议，http是可以基于tcp传输的协议。&lt;/p&gt;

&lt;h3 id=&quot;三socket连接&quot;&gt;三、Socket连接&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Socket为长连接：&lt;/strong&gt;Socket 是对 TCP/IP 协议的封装，Socket 只是个接口不是协议，通过 Socket 我们去使用 TCP/IP 协议，除了 TCP，也可以使用 UDP 协议来传递数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Socket&lt;/strong&gt;也称作&lt;strong&gt;套接字&lt;/strong&gt;，套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示。建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。&lt;/p&gt;

&lt;p&gt;套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务器监听&lt;/strong&gt;：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;客户端请求&lt;/strong&gt;：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;连接确认&lt;/strong&gt;：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;HTTP连接使用的是”请求-响应”方式，不仅在请求时才建立连接，而且客户端向服务器端请求后，服务器才返回数据。&lt;/p&gt;

&lt;p&gt;创建 Socket 连接的时候，可以指定传输层协议，可以是 TCP 或者 UDP。通常情况下Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。&lt;/p&gt;

&lt;p&gt;很多情况下，都是需要服务器端向客户端主动推送数据，保持客户端与服务端的实时同步。&lt;/p&gt;

&lt;p&gt;若双方是 Socket 连接，可以由服务器直接向客户端发送数据。&lt;/p&gt;

&lt;p&gt;若双方是 HTTP 连接，则服务器需要等客户端发送请求后，才能将数据回传给客户端。&lt;/p&gt;

&lt;p&gt;因此，客户端定时向服务器端发送请求，不仅可以保持在线，同时也询问服务器是否有新数据，如果有就将数据传给客户端。&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/%E6%9C%89%E4%BA%86HTTP%E4%B8%BA%E4%BD%95%E8%BF%98%E6%9C%89RPC/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/%E6%9C%89%E4%BA%86HTTP%E4%B8%BA%E4%BD%95%E8%BF%98%E6%9C%89RPC/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>go语言 reflection 反射</title>
        <description>&lt;h1 id=&quot;reflection-反射主要作用&quot;&gt;reflection 反射主要作用&lt;/h1&gt;
&lt;p&gt;通过rValue:=reflect.ValueOf可以操作值
1.动态修改数据 rValue.Elem().setXXX()
2.动态调用方法 rValuse.Method(0).call()/可以通过数量或者方法名称调用
通过reflect.TypeOf可以操纵类型
1.类型判断 
2.查看结构体方法 名称,方法数量,有几个参数,有几个返回值
3.reflect.Ptr(int string) 确定是否是指针(或者整型 字符串等等)
共用
1.类型转换(struct-Map)互转&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;reflect&quot;
	&quot;fmt&quot;
)

type Person struct {
	Name		string
	Birthday	string
	Age     	int
	Address		string
}

type User struct {
	Name string
	Age int
	Sex string
}

func main()  {
	person := Person{&quot;华华&quot;, &quot;2000-01-01&quot;, 18, &quot;北京&quot;}
	//personMap := make(map[string]string)
	personMap := StructToMap(person)
	fmt.Printf(&quot;%T\n&quot;, personMap)
	fmt.Println(personMap)

	myMap := map[string]interface{}{&quot;Name&quot;:&quot;小二&quot;, &quot;Age&quot;:12, &quot;Sex&quot;:&quot;男&quot;}
	user := User{}
	MapToStruct(myMap, &amp;amp;user)
	fmt.Println(&quot;user:&quot;, user)
}

func StructToMap(struc interface{}) map[string]interface{} {
	rValue := reflect.ValueOf(struc)
	rType := reflect.TypeOf(struc)
	if rType.Kind() != reflect.Struct {
		return nil
	}
	myMap := make(map[string]interface{})
	for i := 0; i &amp;lt; rValue.NumField(); i++ {
		vField := rValue.Field(i)
		tField := rType.Field(i)
		fmt.Println(vField, tField.Name)
		myMap[tField.Name] = vField.Interface()
	}

	return myMap
}

func MapToStruct(myMap map[string]interface{}, struc interface{}) {
	rValue := reflect.ValueOf(struc)
	if rValue.Kind() != reflect.Ptr {
		fmt.Println(&quot;修改的数据类型不是指针&quot;)
		return
	}
	elem := rValue.Elem()
	if !elem.CanSet() {
		fmt.Println(&quot;不能设置&quot;)
	}
	for key, value := range myMap {
		//下面两行代码相当与 struc.key = value
		field := elem.FieldByName(key)
		field.Set(reflect.ValueOf(value))
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/reflection-%E5%8F%8D%E5%B0%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/reflection-%E5%8F%8D%E5%B0%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>go网络编程POST</title>
        <description>&lt;h1 id=&quot;http编程post&quot;&gt;http编程POST&lt;/h1&gt;
&lt;p&gt;POST通过body来给服务器发送数据,给服务器发送请求和GET很像,但是函数内会多两个参数,一个contentType,用来表示post提交数据的格式
一般分为4种
1.application/x-www-form-urlencoded
表单格式
以这种格式提交到服务器的数据服务器可以通过ParseForm()来解析和GET提交到服务器用法差不多   FORM就是一个表单
2.text/html或者text/plain
这俩种方式提交到服务器,会直接到r.body里,需要通过切片读取读取
3.MULTIPART/FORM-DATA
略
4.APPLICATION/JSON
略
还有一个参数是body,是用来给服务器传参数用的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;bytes&quot;
	&quot;net/url&quot;
	&quot;sanqi/0604socket/help&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

func main()  {
	//构建参数
	param:=url.Values{
		&quot;theCityName&quot;:{&quot;北京&quot;},
	}
	//构建请求体 转化位body
	buffer := bytes.NewBufferString(param.Encode())  //map转换成string
	//发起post请求
	//         ip地址				路径
	//http://www.webxml.com.cn/WebServices/WeatherWebService.asmx/getWeatherbyCityName
	response, _ := http.Post(&quot;www.webxml.com.cn/WebServices/WeatherWebService.asmx/getWeatherbyCityName&quot;,
		&quot;application/x-www-form-urlencoded&quot;, buffer)
	if response.StatusCode==200{  //判断是否是200
		//操作响应数据
		defer response.Body.Close() //关闭
		//读取body里面的数据
		bytes, err := ioutil.ReadAll(response.Body)  //读取body中的reader方法
		help.CheckErr(err)

		fmt.Println(&quot;111111&quot;,response.Body)  //body是个接口
		//打印响应体里面的数据
		fmt.Println(&quot;222222&quot;,string(bytes))  //body是个接口

	}else {
		fmt.Println(&quot;请求失败&quot;,response.Status) //打印状态码
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;剩下俩种方法,跟GET差不多,就是新建个body就可以了
第二种也是新建请求,可以添加请求中的数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;sanqi/0604socket/help&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/url&quot;
	&quot;bytes&quot;
)

func main()  {
	//1.创建一个客户端
	client:=http.Client{}

	//构建参数
	param:=url.Values{
		&quot;theCityName&quot;:{&quot;北京&quot;},
	}
	//构建请求体 转化位body
	buffer := bytes.NewBufferString(param.Encode())  //map转换成string
	//2.创建一个请求
	request, err := http.NewRequest(&quot;POST&quot;, &quot;http://www.webxml.com.cn/WebServices/WeatherWebService.asmx/getWeatherbyCityName&quot;, buffer) //新建一个请求
	if err!=nil{
		fmt.Println(&quot;psot数据失败&quot;,err)
	}
	//添加cookie
	//fmt.Println(request)
	//3.客户端发送请求
	//设置请求头
	request.Header.Set(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)
	response, err := client.Do(request)

	//查看请求头
	fmt.Printf(&quot;Header%+v\n&quot;,request.Header)
	requestBody,err:=ioutil.ReadAll(request.Body)
	fmt.Printf(&quot;requestBody%+v\n&quot;,string(requestBody))


	if err!=nil{
		fmt.Println(&quot;客户端发送请求失败&quot;,err)
	}
	defer response.Body.Close()  //关闭
	fmt.Printf(&quot;%v\n%v\n&quot;,response.StatusCode,response.Header)
	//4.操作数据
	if  response.StatusCode==http.StatusOK{
		bytes, err := ioutil.ReadAll(response.Body)
		help.CheckErr(err)
		fmt.Println(string(bytes))


	}else {
		fmt.Println(&quot;网络请求失败&quot;,response.Status)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###第三种是通过客户端client.post来请求服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;sanqi/0604socket/help&quot;
	&quot;io/ioutil&quot;
	&quot;fmt&quot;
	&quot;net/url&quot;
	&quot;bytes&quot;
)

func main()  {
	//构建参数
	param:=url.Values{
		&quot;theCityName&quot;:{&quot;北京&quot;},
	}
	//构建请求体 转化位body
	buffer := bytes.NewBufferString(param.Encode())  //map转换成string
	//创建客户端
	client := http.Client{}
	//通过client去请求
	response, err := client.Post(&quot;http://www.webxml.com.cn/WebServices/WeatherWebService.asmx/getWeatherbyCityName&quot;,&quot;application/x-www-form-urlencoded&quot;,buffer)
	help.CheckErr(err)
	if response.StatusCode==http.StatusOK{
		defer response.Body.Close()
		bytes, err := ioutil.ReadAll(response.Body)
		if err!=nil{
			fmt.Println(err)
		}
		fmt.Println(string(bytes))   //打印请求body
		fmt.Println(response.Header)  //打印请求头
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;服务器这边也是跟GET差不多的,通过HandleFunc()来控制调用函数,通过客户端传来的body,服务器来判断给客户端回复什么数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;fmt&quot;
)
func ServeHTTP3(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()//解析客户端发送过来的参数
	fmt.Println(r.FormValue(&quot;theCityName&quot;))
	if len(r.FormValue(&quot;theCityName&quot;))&amp;gt;0{
		fmt.Println(r.FormValue(&quot;theCityName&quot;)[0])  //通过k来找value
		if r.FormValue(&quot;theCityName&quot;)==&quot;北京&quot;{
			responsrstr:=`&amp;lt;ArrayOfString xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
  &amp;lt;string&amp;gt;访问被限制！&amp;lt;/string&amp;gt;
	w.Write([]byte(responsrstr))
		}
	}
	fmt.Println(r.Header) //打印请求头
	fmt.Println(r.Method) //打印请求方法
	fmt.Println(r.Cookie) //打印客户端cookie
	fmt.Println(r.URL)
	if r.Method==&quot;GET&quot;{
		w.Write([]byte(&quot;不安全&quot;))
	}
	w.Write([]byte(&quot;第一个go后台程序&quot;))
}
func ServeHTTP4(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte(&quot;哈哈&quot;))
}
func ServeHTTP5(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte(&quot;喵喵&quot;))
}

func main()  {
	mux := http.NewServeMux()  //新建mux
	mux.HandleFunc(&quot;/hi&quot;,ServeHTTP3)  //用mux来监听绑定
	mux.HandleFunc(&quot;/ha&quot;,ServeHTTP5)
	mux.HandleFunc(&quot;/miao&quot;,ServeHTTP4)

	http.ListenAndServe(&quot;:9527&quot;,mux)
	
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/http%E7%BC%96%E7%A8%8BPOST/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/http%E7%BC%96%E7%A8%8BPOST/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>go网络编程GET</title>
        <description>&lt;h1 id=&quot;http编程-get-方法&quot;&gt;http编程 Get 方法&lt;/h1&gt;

&lt;p&gt;客户端给服务器发送请求,服务器根据请求给予回应
go有三种Get请求方法&lt;/p&gt;

&lt;p&gt;###第一种直接GET
这种方法直接接收服务器的回应,得到服务器回应后,把body里的数据读取出来&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;sanqi/0604socket/help&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

func main()  {
	//获取服务器的数据
	resp, err := http.Get(&quot;https://www.baidu.com&quot;)
	help.CheckErr(err)
	//fmt.Printf(&quot;%+v\n&quot;,resp)
	if resp.StatusCode==200{  //判断是否是200
		//操作响应数据
		defer resp.Body.Close() //关闭
		//读取body里面的数据
		bytes, err := ioutil.ReadAll(resp.Body)  //读取body中的reader方法
		help.CheckErr(err)

		//打印响应体里面的数据
		fmt.Println(string(bytes))  //body是个接口

	}else {
		fmt.Println(&quot;请求失败&quot;,resp.Status) //打印状态码
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###第二种新建请求
先新建客户端(client),在新建请求(NewRequest)
在通过client.Do(Request)请求服务器给予回复
好处就是可以先编辑请求,然后再发出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;sanqi/0604socket/help&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

func main()  {
	//1.创建一个客户端
	client:=http.Client{}
	//2.创建一个请求
	request, err := http.NewRequest(&quot;GET&quot;, &quot;https://www.toutiao.com/search/suggest/initial_page/&quot;, nil) //新建一个请求
	if err!=nil{
		fmt.Println(&quot;get数据失败&quot;,err)
	}
	//添加cookie
	fmt.Println(request)
	cookieName := http.Cookie{Name: &quot;liujiao&quot;, Value: &quot;hahaha&quot;}
	request.AddCookie(&amp;amp;cookieName) //把创建的cookie放到请求里取去
	//3.客户端发送请求
	response, err := client.Do(request)  //把请求发送到url网址 得到服务器响应
	//设置请求头
	request.Header.Set(&quot;Accept-Lanauage&quot;,&quot;zh-cn&quot;)

	//查看请求头
	fmt.Printf(&quot;Header%+v\n&quot;,request.Header)
	//requestBody,err:=ioutil.ReadAll(request.Body)
	//fmt.Printf(&quot;requestBody%+v\n&quot;,requestBody)


	if err!=nil{
		fmt.Println(&quot;客户端发送请求失败&quot;,err)
	}
	defer response.Body.Close()  //关闭
	fmt.Printf(&quot;%v\n%v\n&quot;,response.StatusCode,response.Header)
	//4.操作数据
	if  response.StatusCode==http.StatusOK{
		bytes, err := ioutil.ReadAll(response.Body)
		help.CheckErr(err)
		fmt.Println(string(bytes))


	}else {
		fmt.Println(&quot;网络请求失败&quot;,response.Status)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###第三种新建客户端直接GET
和直接http.get差不多&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;sanqi/0604socket/help&quot;
	&quot;io/ioutil&quot;
	&quot;fmt&quot;
)

func main()  {
	//创建客户端
	client := http.Client{}
	//通过client去请求
	response, err := client.Get(&quot;https://www.toutiao.com/search/suggest/initial_page/&quot;)
	help.CheckErr(err)
	if response.StatusCode==http.StatusOK{
		defer response.Body.Close()
		bytes, err := ioutil.ReadAll(response.Body)
		if err!=nil{
			fmt.Println(err)
		}
		fmt.Println(string(bytes))   //打印请求body
		fmt.Println(response.Header)  //打印请求头
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GET还可以通过路径来请求服务器端的方法
http://localhost:9527/hi?theCityName=北京
正常url后面跟的是调用方法名称/hi
theCityName是map的k,通过服务器通过r.ParseForm()可以得到value
=后面是map的value&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
)

func main()  {
	resp, _ := http.Get(&quot;http://localhost:9527/hi?theCityName=北京&quot;)
	bytes, _ := ioutil.ReadAll(resp.Body)
	fmt.Println(string(bytes))

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###服务器端
http.HandleFunc通过客户端发来的调用方法的名称,来调用对应的方法,
func ServeHTTP3(w http.ResponseWriter, r *http.Request)两个参数是固定写法,w代表给客户端回复的数据,r代表客户端传来的数据,
可以通过r.ParseForm()来解析客户端发来的数据
r.form 是给map,可以通过客户端传来的k来取里面的v,通过v来做判断给客户端回复相对应的数据
w.Write可以直接写数据给客户端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/http&quot;
	&quot;fmt&quot;
)
func ServeHTTP3(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()//解析客户端发送过来的参数
	fmt.Println(r.FormValue(&quot;theCityName&quot;))
	if len(r.FormValue(&quot;theCityName&quot;))&amp;gt;0{
		fmt.Println(r.FormValue(&quot;theCityName&quot;)[0])  //通过k来找value
		if r.FormValue(&quot;theCityName&quot;)==&quot;北京&quot;{
			responsrstr:=`&amp;lt;ArrayOfString xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
  &amp;lt;string&amp;gt;访问被限制！&amp;lt;/string&amp;gt;
	w.Write([]byte(responsrstr))
		}
	}
	fmt.Println(r.Header) //打印请求头
	fmt.Println(r.Method) //打印请求方法
	fmt.Println(r.Cookie) //打印客户端cookie
	fmt.Println(r.URL)
	if r.Method==&quot;GET&quot;{
		w.Write([]byte(&quot;不安全&quot;))
	}
	w.Write([]byte(&quot;第一个go后台程序&quot;))
}
func ServeHTTP4(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte(&quot;哈哈&quot;))
}
func ServeHTTP5(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte(&quot;喵喵&quot;))
}

func main()  {
	mux := http.NewServeMux()  //新建mux
	mux.HandleFunc(&quot;/hi&quot;,ServeHTTP3)  //用mux来监听绑定
	mux.HandleFunc(&quot;/ha&quot;,ServeHTTP5)
	mux.HandleFunc(&quot;/miao&quot;,ServeHTTP4)

	http.ListenAndServe(&quot;:9527&quot;,mux)
	
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/http%E7%BC%96%E7%A8%8B-Get-%E6%96%B9%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/http%E7%BC%96%E7%A8%8B-Get-%E6%96%B9%E6%B3%95/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>go网络编程总结</title>
        <description>&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;###Socket 服务端 (tcp或udp)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;net.Listen(“tcp”,”ip:port”) 监听  –&amp;gt;  conn:= lister.Accept()  等待链
接–&amp;gt;conn read||conn.Write 或者写&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###Socket 客户端 (tcp或udp)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;客户端 conn:=net.Dial(“tcp”,”ip:port”) 链接服务器 –&amp;gt; conn read&lt;/td&gt;
        &lt;td&gt; &lt;/td&gt;
        &lt;td&gt;conn.Write 读或写&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;###rpc传输 服务器(1)调用服务器(2)的方法
###服务器(1) 调用方&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;client, err := rpc.DialHTTP(“tcp”, “:8888”) //链接服务器(2)
client.Call(“MyMath.Add”, Param{23,9}, &amp;amp;sum) //调用服务器(2)的MyMath.Add方法  Param是参数1(方法调用所需的参数), sum是参数2(服务器2给返回的结果,所以一定要传指针)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###服务器(2) 被调用方&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//注册的结构体,将方法绑定到RPC服务
type MyMath struct {
}
//提供方法所需要的参数
type Param struct {  //因为只能接收一个值 所有要创建结构体
	A int
	B int
}
//这是提供给客户端调用的方法
func (m *MyMath) Add(param Param,sum *int)error  {
	*sum=param.A+param.B
	return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;rpc.Register(new(MyMath)) //把结构体注册到rpc 等待调用
rpc.HandleHTTP() //把rpc绑定到http里
http.ListenAndServe(“:8888”,nil) //通过http来监听&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;###http协议 客户端 GET 获取网页内容&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;resp, err := http.Get(“https://www.baidu.com”)  //获取网页内容,
bytes, err := ioutil.ReadAll(resp.Body)  //网页的内容全在body里,可以读取出来 ,bytes就是读取出的内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###http协议 客户端 GET 请求服务端&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;resp, _ := http.Get(“http://localhost:9527/hi?theCityName=北京”)  //?后面是请求服务器的参数,服务器会根据参数给予不同的回应 
bytes, _ := ioutil.ReadAll(resp.Body) //服务器给予的回应都在body里,可以读取出来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###http协议 客户端 POST 请求服务端&lt;/p&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;param:=url.Values{  //post请求是通过body来给客户端传递参数的,所以要创建body &quot;theCityName&quot;:{&quot;北京&quot;}, }   //buffer实现了io.Reader,所以创建一个buffer,可以当body用 buffer :=bytes.NewBufferString(param.Encode())  //转换成string //POST请求有三个参数,1.url/路径 2.编码格式, 3 请求body response, _ := http.Post(&quot;http://localhost:9527/hi&quot;,&quot;application/x-www-form-urlencoded&quot;, buffer)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;###http协议 服务端&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;http.HandleFunc(&quot;/hi&quot;,ServeHTTP)//pattern是url的路径 域名后面的路径
&amp;gt;//如果客户端发来hi,就调用ServeHTTP方法给予客户端回复
&amp;gt;http.ListenAndServe(&quot;:9527&quot;,nil)  //监听9527端口
&amp;gt;//下面是ServeHTTP方法
&amp;gt;func ServeHTTP(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()//解析客户端发送过来的参数
	fmt.Println(r.Form[&quot;theCityName&quot;][0])
	fmt.Println(r.FormValue(&quot;theCityName&quot;))
	if len(r.FormValue(&quot;theCityName&quot;))&amp;gt;0{
		fmt.Println(r.FormValue(&quot;theCityName&quot;)[0])  //通过k来找value
		if r.FormValue(&quot;theCityName&quot;)==&quot;北京&quot;{
			responsrstr:=`&amp;lt;ArrayOfString xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns=&quot;http://WebXml.com.cn/&quot;&amp;gt;
  &amp;lt;string&amp;gt;访问被限制！&amp;lt;/string&amp;gt;
  &amp;lt;string&amp;gt;2018-06-05 16:54:34&amp;lt;/string&amp;gt;
  &amp;lt;string&amp;gt;免费用户24小时内访问超过规定数量。联系我们：http://www.webxml.com.cn/&amp;lt;/string&amp;gt;
`
	w.Write([]byte(responsrstr))
		}
	}
	fmt.Println(r.Header) //打印请求头
	fmt.Println(r.Method) //打印请求方法
	fmt.Println(r.Cookie) //打印客户端cookie
	fmt.Println(r.URL)
	if r.Method==&quot;GET&quot;{
		w.Write([]byte(&quot;不安全&quot;))
	}
	w.Write([]byte(&quot;第一个go后台程序&quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/go%E7%BD%91%E8%B7%AF%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/go%E7%BD%91%E8%B7%AF%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>go网络编程RPC</title>
        <description>&lt;h1 id=&quot;rpc通信协议&quot;&gt;RPC通信协议&lt;/h1&gt;
&lt;p&gt;服务器和服务器之间的方法调用,
rpc 不支持夸语言, 
只能通过jsonrpc夸语言
要调用服务器上的方法,
先要服务器声明结构体,并且实现一些方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//注册的结构体,将方法绑定到RPC服务
type MyMath struct {

}

//提供方法所需要的参数
type Param struct {  //因为只能接收一个值 所有要创建结构体
	A int
	B int
}

type ResponseData struct {
	Mod int //商
	Yushu int //余数
}

//这是提供给客户端调用的方法
func (m *MyMath) Add(param Param,sum *int)error  {
	*sum=param.A+param.B
	return nil

}

func (m *MyMath) Div(param Param,data *ResponseData) error {
	data.Mod=param.A/param.B
	data.Yushu=param.A%param.B
	return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结构体注册RPC服务里,
然后把RPC服务绑定在http服务上,最后开始监听端口,看是否有别的服务端来链接端口调用方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func main()  {
	//注册rpc服务
	err:=rpc.Register(new(MyMath))
	if err!=nil{
		fmt.Println(&quot;注册失败&quot;,err)
	}
	//将rpc的服务绑定到http包中
	rpc.HandleHTTP()
	fmt.Println(&quot;监听中&quot;)
	//监听端口 客户端访问的时候访问的就是MyMath
	http.ListenAndServe(&quot;:8888&quot;,nil)

	/*
	实现MyMath的方法,就是提供给客户端的服务
	客户端可以直接调用MyMath里面的方法 ,这个方法有一定的要求
	1.该方法必须属于MyMath
	2.必须要有两个参数,第一个参数就是该方法的参数,第二个是返回值并且是一个指针(这样服务端才能修改),不管需要多少给参数,被调用方法只能接收一个参数
	3.必须有一个返回值,返回值的类型是error的类型
	 */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###调用端(第二个服务器)
通过rpc.DialHTTP来链接,来链接服务器(第一个服务器),通过返回client来调用call方法,再通过call方法来调用服务器的方法(第一个服务器)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package rpc

import (
	&quot;net/rpc&quot;
	&quot;fmt&quot;
)

//用作参数
type Param struct {  //因为只能接收一个值 所有要创建结构体
	A int
	B int
}
//接收参数
type ResponseData struct {
	Mod int //商
	Yushu int //余数
}


func main()  {
	client, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;:8888&quot;)
	if err!=nil{
		fmt.Println(err)
	}
	fmt.Println(&quot;链接成功&quot;)
	//调用rpc服务的方法,就相当于http.get请求
	//MyMath就是服务端提供的方法的类,add就是对应的方法
	sum:=0   //										参数1 传的值		参数2 返回的结果
	err = client.Call(&quot;MyMath.Add&quot;, Param{23,9}, &amp;amp;sum)
	if err!=nil{

	}
	fmt.Println(sum)
	div:=ResponseData{}

	err = client.Call(&quot;MyMath.Div&quot;, Param{120,55}, &amp;amp;div)
	if err!=nil{

	}
	fmt.Println(&quot;商&quot;,div.Mod,&quot;余数&quot;,div.Yushu)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###客户端通过第二台(总服务器)去调第三台服务器的方法
可以通过浏览器(客户端)来通过总服务器,去调第三台服务器的方法,也可以用GET或者POST给总服务器传参数过来,GET直接url:port?k1=v1&amp;amp;k2=v2,post把值存入body里传过来,再由总服务器进行调用并且把值回传给客户端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (

	&quot;net/http&quot;
	&quot;net/rpc/jsonrpc&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;strconv&quot;
)

type Param struct {
	//因为只能接收一个值 所有要创建结构体
	A int
	B int
}
//可以通过get和post方法来调用
func add(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	fmt.Println(r.FormValue(&quot;a&quot;))
	a,_:=strconv.Atoi(r.FormValue(&quot;a&quot;))
	fmt.Println(r.FormValue(&quot;b&quot;))
	b,_:=strconv.Atoi(r.FormValue(&quot;b&quot;))
	p:=Param{a,b}
	sum:=linkRpc(p)  //调用别的服务上的方法
	w.Write([]byte(strconv.Itoa(sum)))


}
//客户端链接总务器 通过/add来调 第二台服务器中的方法
func main()  {
	mux := http.NewServeMux()
	mux.HandleFunc(&quot;/add&quot;,add)
	http.ListenAndServe(&quot;:3000&quot;,mux)



}

func linkRpc(param Param) int {


	//使用jsonrpc
	client, err := jsonrpc.Dial(&quot;tcp&quot;, &quot;:8888&quot;)
	if err!= nil{

		log.Fatal(err)
	}
	//远程调用方法
	sum:=0
	client.Call(&quot;MyMath.Add&quot;,param,&amp;amp;sum)
	fmt.Println(sum)
	return sum
}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/RPC%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/RPC%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>MySQL和go交互</title>
        <description>&lt;h1 id=&quot;mysql和go交互&quot;&gt;MySQL和go交互&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;database/sql&quot;
	_&quot;github.com/go-sql-driver/mysql&quot;

	&quot;fmt&quot;
)

func main()  {
	//打开mysql
	//db就是go1803 ,这个数据库的文件
	//root:password@tcp(ip:port)/mysql
	db, err := sql.Open(&quot;mysql&quot;, &quot;root:liu713@tcp(localhost:3306)/go1803?charset=utf8&quot;)
	if err!=nil{
		panic(err)
	}
	//myAdd(db)  //增
	//myPrepare(db) //准备 + 删除
	//myModify(db) //修改
	//myquery(db)  //查询
	//myTx(db)    //事务
	myQueryFunc(db)
}

func createTable(db *sql.DB)  {
	//创建表
	db.Exec(`create table if not exists emp3(emp_no int(4) primary key auto_increment not null,
	emp_name varchar(20) not null, job varchar(10) default &quot;前台&quot;, salary float default 0);`)

}

func myQueryFunc(db *sql.DB)  {
	//函数查询
	row := db.QueryRow(&quot;SELECT COUNT (emp_no) FROM emp&quot;)
	d:=&quot;&quot;
	row.Scan(&amp;amp;d)
	fmt.Println(d)
}

func myTx(db *sql.DB)  {
	//事务 要所有都成功提交 才修改数据库
	tx, _ := db.Begin()
	result, _ := tx.Exec(&quot;UPDATE emp SET salary=? WHERE emp_no=?&quot;, 20000,1001)
	i, _ := result.RowsAffected()
	result, _ = tx.Exec(&quot;UPDATE emp SET salary=? WHERE emp_no=?&quot;, 13000,1002)
	i1, _ := result.RowsAffected()
	fmt.Printf(&quot;i:%d,i2:%d&quot;,i,i1)
	if i&amp;gt;0&amp;amp;&amp;amp;i1&amp;gt;0{
		tx.Commit()  //提交
	}else {
		tx.Rollback() //回滚到修改之前
	}
}


//删除
func myPrepare(db *sql.DB)  {
	//提前准备
	prepare, _ := db.Prepare(&quot;DELETE FROM emp WHERE emp_no=?&quot;)
	result, _ := prepare.Exec(&quot;1006&quot;)
	i, _ := result.RowsAffected()
	fmt.Println(&quot;一共修改了&quot;,i,&quot;条数据&quot;)
}


//新增数据  主键不能重复 所以只能执行一次
func myAdd(db *sql.DB)  {
	result, _ := db.Exec(&quot;INSERT INTO emp VALUES (?,?,?,?)&quot;, &quot;1006&quot;, &quot;三胖&quot;, &quot;老板&quot;, &quot;50000&quot;)
	i, _ := result.RowsAffected()
	fmt.Println(&quot;一共修改了&quot;,i,&quot;条数据&quot;)

}

//修改
func myModify(db *sql.DB)  {
	//Exec 可以执行增删改查  有几个问号 后面就要有几个参数
	result, _ := db.Exec(&quot;UPDATE emp SET salary=? WHERE emp_no=?&quot;, &quot;17000&quot;, &quot;1005&quot;)
	i, _ := result.RowsAffected() //有没有成功 修改了几个
	fmt.Println(&quot;一共修改了&quot;,i,&quot;条数据&quot;)

}



//查询方法
func myquery(db *sql.DB)  {

	//查询一条数据
	row := db.QueryRow(&quot;SELECT emp_name,job FROM emp WHERE emp_no=?&quot;, &quot;1003&quot;)
	emp_Name:=&quot;&quot;
	job:=&quot;&quot;
	//通过scan获取字段
	row.Scan(&amp;amp;emp_Name,&amp;amp;job)
	fmt.Println(emp_Name)
	fmt.Println(job)
	rows, _ := db.Query(&quot;SELECT *FROM emp&quot;)
	//循环下一个内容
	for rows.Next(){
		emp_no:=&quot;&quot;
		salary:=0
		rows.Scan(&amp;amp;emp_no,&amp;amp;emp_Name,&amp;amp;job,&amp;amp;salary)
		fmt.Println(emp_no,emp_Name,job,salary)
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/MySQL%E5%92%8Cgo%E4%BA%A4%E4%BA%92/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/MySQL%E5%92%8Cgo%E4%BA%A4%E4%BA%92/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>MySQL命令</title>
        <description>&lt;p&gt;#命令 
进入 mysql -u root -p
输入密码&lt;/p&gt;

&lt;p&gt;忘记密码&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击系统偏好设置-&amp;gt;最下边点MySQL，在弹出页面中，关闭服务&lt;/li&gt;
  &lt;li&gt;cd /usr/local/mysql/bin/&lt;/li&gt;
  &lt;li&gt;sudo su&lt;/li&gt;
  &lt;li&gt;./mysqld_safe –skip-grant-tables &amp;amp;&lt;/li&gt;
  &lt;li&gt;回车后mysql会自动重启，在偏好设置中mysql的状态会变成running&lt;/li&gt;
  &lt;li&gt;./mysql&lt;/li&gt;
  &lt;li&gt;FLUSH PRIVILEGES;&lt;/li&gt;
  &lt;li&gt;SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘新密码’);&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mysql-的dos命令&quot;&gt;mysql 的dos命令&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查询数据库的版本&lt;/p&gt;

    &lt;p&gt;select version();&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前的时间&lt;/p&gt;

    &lt;p&gt;select now();&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前的数据库&lt;/p&gt;

    &lt;p&gt;show databases;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建数据库：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create database if not exists go default charset utf8 collate utf8_general_ci;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;若报错 &lt;code class=&quot;highlighter-rouge&quot;&gt;ERROR 1044 (42000): Access denied for user ''@'localhost' to database 'day0511'&lt;/code&gt; 是权限问题，需 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql -u root -p&lt;/code&gt; 进入MySQL。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换数据库&lt;/p&gt;

    &lt;p&gt;use day0510(数据库名)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前操作的数据库&lt;/p&gt;

    &lt;p&gt;select database();&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除数据库&lt;/p&gt;

    &lt;p&gt;drop database if exists day0511(数据库名);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看该数据库下的数据表&lt;/p&gt;

    &lt;p&gt;show tables;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建数据表&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table if not exists users( 
id int(4) primary key auto_increment not null,
age int(4) default 20,
price float,
name varchar(20) unique not null,
password varchar(30) not null ); 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;strong&gt;约束&lt;/strong&gt;：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;主键约束：primary key&lt;/p&gt;

        &lt;p&gt;主键约束：要求该字段数值不允许空，而且数值唯一。(not null+unique)&lt;/p&gt;

        &lt;p&gt;主键约束用于唯一的标识表中的每一个行记录的。一个表中最多只能有一个主键约束。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;主键自增：&lt;/strong&gt; auto_increment&lt;/p&gt;

        &lt;p&gt;要求该字段数值不允许空，而且数值唯一。所以我们通常会指定主键类型为整型，然后设置其自动增长，这样可以保证在插入数据时主键列的唯一和非空特性。&lt;/p&gt;

        &lt;p&gt;删除主键：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;添加主键：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;teachers&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;修改表时设置主键自动增长：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;modify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;auto_increment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;修改表时删除主键自动增长：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;modify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;默认值：default&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;非空约束：not null&lt;/p&gt;

        &lt;p&gt;如果某个字段添加了非空约束，那么该字段的数值不能为null，对于mysql而言，表示什么都没有，未知的。不是0，也不是空”“，更不是”NULL”。&lt;/p&gt;

        &lt;p&gt;删除非空约束：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stu&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;modify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sname&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;添加非空约束：&lt;/p&gt;

        &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;modify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;唯一性约束：unique&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;唯一性约束强调所在的字段所有的数值都是唯一的。不允许重复。允许空值（多个）。&lt;/p&gt;

    &lt;p&gt;删除唯一约束：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;modify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;添加唯一约束：&lt;/p&gt;

    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;modify&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unique&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;外键约束：foreign key（略）&lt;/p&gt;

        &lt;p&gt;​&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看表结构&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;desc users(表名);&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看表数据&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;select * from users;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看建表时的语句&lt;/p&gt;

    &lt;p&gt;show create table users;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加字段&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alter table users add(
note varchar(40),
rtime date);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改字段类型&lt;/p&gt;

    &lt;p&gt;注意事项：&lt;/p&gt;

    &lt;p&gt;A：如果数据表中没有数据(空表)，可以任意修改字段类型&lt;/p&gt;

    &lt;p&gt;B：如果数据表中有数据，只能修改兼容类型，注意长度。&lt;/p&gt;

    &lt;p&gt;alter table users modify password char(20);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更改字段的名字&lt;/p&gt;

    &lt;p&gt;alter table users change password pwd char(20);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更改表名&lt;/p&gt;

    &lt;p&gt;rename table users to user2;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除表&lt;/p&gt;

    &lt;p&gt;drop table if exists user2;&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;修改数据&quot;&gt;修改数据&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;插入数据：&lt;/p&gt;

    &lt;p&gt;A：全列插入&lt;/p&gt;

    &lt;p&gt;insert into 表名 values(v1，v2，v3….)&lt;/p&gt;

    &lt;p&gt;Values后数值的个数，必须和字段的个数一致。&lt;/p&gt;

    &lt;p&gt;insert into user2 values(0,’三胖’,’123456’,’有点胖’,’2018-04-18’);&lt;/p&gt;

    &lt;p&gt;B：缺省插入&lt;/p&gt;

    &lt;p&gt;insert into 表名(字段1，字段2，字段3…)values (v1，v2，v3.。。)&lt;/p&gt;

    &lt;p&gt;自增的主键，自动添加数据。&lt;/p&gt;

    &lt;p&gt;insert into user2(username, note) values(‘老二’,’傻傻的’);&lt;/p&gt;

    &lt;p&gt;C：同时插入多条数据&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insert into users
values
(0,'tom','tom666','猫','2018-03-21'),
(0,'jerry','memeda','mouse','2017-10-10');
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insert into user2
(name,pwd)
values
('jessica','987654'),
('如花','654654');
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新数据&lt;/p&gt;

    &lt;p&gt;update 表名 set [更新的数据] where [更新的条件]&lt;/p&gt;

    &lt;p&gt;update users set username=’老四’ where uid=4;&lt;/p&gt;

    &lt;p&gt;update users set note=’酷酷的’ where username&amp;lt;&amp;gt;jessica;&lt;/p&gt;

    &lt;p&gt;update users set note=’大学生’ where age between 20 and 25;&lt;/p&gt;

    &lt;p&gt;update users set rtime=’2015-10-10’ where uid in(1,4,6);&lt;/p&gt;

    &lt;p&gt;update users set rtime=’2017-09-09’ where age=26 and note=’酷酷的’;&lt;/p&gt;

    &lt;p&gt;update users set rtime=’2013-1-14’ where pwd is NULL;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除数据&lt;/p&gt;

    &lt;p&gt;delete from 表名 where [删除条件]&lt;/p&gt;

    &lt;p&gt;delete from users where uid=6;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询数据&lt;/p&gt;

    &lt;p&gt;select 列名，列名，列名。。。From 表名&lt;/p&gt;

    &lt;p&gt;select * from users;&lt;/p&gt;

    &lt;p&gt;select age from users;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;条件查询&lt;/p&gt;

    &lt;p&gt;select * from users where note=’大学生’;&lt;/p&gt;

    &lt;p&gt;select age from users where note=’大学生’;&lt;/p&gt;

    &lt;p&gt;select * from users where age=22 or note=’酷酷的’;&lt;/p&gt;

    &lt;p&gt;select * from users where age&amp;gt;=25 and age&amp;lt;=28;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;条件是可选的&lt;/p&gt;

      &lt;ol&gt;
        &lt;li&gt;条件必须是boolean类型的值或者表达式&lt;/li&gt;
        &lt;li&gt;运算符：=,!=,&amp;lt;&amp;gt;,&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=,between..and, in(…),or ,and ,not, is null，is not null&lt;/li&gt;
        &lt;li&gt;is null 不是 = null(永远是false)&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模糊查询&lt;/p&gt;

    &lt;p&gt;%通配符代表任意多个字符，_通配符代表任意一个字符&lt;/p&gt;

    &lt;p&gt;select * from users where note like(模糊关键字) ‘%学’;&lt;/p&gt;

    &lt;p&gt;select * from users where note like(模糊关键字)’%生’;&lt;/p&gt;

    &lt;p&gt;select * from users where note like(模糊关键字) ‘%酷%’;&lt;/p&gt;

    &lt;p&gt;select * from users where username like(模糊关键字) ‘老_’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;排序&lt;/p&gt;

    &lt;p&gt;select * from users order by(关键字) age asc; (从小到大)&lt;/p&gt;

    &lt;p&gt;select * from users order by age desc; (从大到小)&lt;/p&gt;

    &lt;p&gt;select * from users order by age,uid desc;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;统计函数（聚合函数）&lt;/p&gt;

    &lt;p&gt;select count(pwd) from users(表名); (总数)&lt;/p&gt;

    &lt;p&gt;select max(age) from users; (最大)&lt;/p&gt;

    &lt;p&gt;select min(age) from users; (最小)&lt;/p&gt;

    &lt;p&gt;select sum(age) from users; (求和)&lt;/p&gt;

    &lt;p&gt;select avg(age) from users; (求平均值)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分页查询&lt;/p&gt;

    &lt;p&gt;select * from users limit 2,5;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;去重查询&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;select distinct note from users;&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/MySQL%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/MySQL%E5%91%BD%E4%BB%A4/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>go网络编程JsonRPC</title>
        <description>&lt;h1 id=&quot;jsonrpc&quot;&gt;JsonRPC&lt;/h1&gt;
&lt;p&gt;可以夸语言来调用别的服务器上的方法,
jsonRPC是给短链接,只会接收一次请求就会断开,jsonrpc需要使用net.Listen来监听,然后等待链接Accept(),最后客户端传来的conn(json格式)传入jsonrpc.ServeConn(conn)转换成普通格式&lt;/p&gt;

&lt;p&gt;###服务端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/rpc/jsonrpc&quot;
	&quot;net/rpc&quot;
	&quot;fmt&quot;
	&quot;net&quot;
)

//注册的结构体,将方法绑定到RPC服务
type MyMath struct {
}

//提供方法所需要的参数
type Param struct {
	//因为只能接收一个值 所有要创建结构体
	A int
	B int
}

type ResponseData struct {
	Mod   int //商
	Yushu int //余数
}

//这是提供给客户端调用的方法
func (m *MyMath) Add(param Param, sum *int) error {
	*sum = param.A + param.B
	return nil

}

func (m *MyMath) Div(param Param, data *ResponseData) error {
	data.Mod = param.A / param.B
	data.Yushu = param.A % param.B
	return nil
}

func main() {
	//注册RPC服务
	err := rpc.Register(new(MyMath))
	if err != nil {
		fmt.Println(err)
	}
	//通过桥接httphand
	//将rpc服务绑定到http
	rpc.HandleHTTP()
	//监听端口
	listener, err := net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)
	if err != nil {
		fmt.Println(err)
	}
	//josnrpc完成一次会主动关闭链接,所有需要开一个死循环
	for {
		//等待链接
		conn, err := listener.Accept() //阻塞 所有要开协程
		if err != nil {
			fmt.Println(err)
		}
		//防止不去阻塞别的客户端的调用
		go func(conn net.Conn) {
			//把链接传到jsonrpc里面 转成普通格式
			jsonrpc.ServeConn(conn)

		}(conn)
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###客户端
客户端就很简单了,直接链接jsonrpc链接,利用call方法就可以调用服务器里面的方法了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/rpc/jsonrpc&quot;
	&quot;log&quot;
	&quot;fmt&quot;
)

type Param struct {
	//因为只能接收一个值 所有要创建结构体
	A int
	B int
}

func main()  {
	//使用jsonrpc 链接客户端
	client, err := jsonrpc.Dial(&quot;tcp&quot;, &quot;:8888&quot;)
		if err!= nil{
			log.Fatal(err)
		}
		//远程调用方法
		sum:=0
		client.Call(&quot;MyMath.Add&quot;,Param{2,5},&amp;amp;sum)
		fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/JsonRPC/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/JsonRPC/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
      <item>
        <title>JSON简介</title>
        <description>&lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;

&lt;h3 id=&quot;1-json&quot;&gt;1. JSON&lt;/h3&gt;

&lt;p&gt;是一种轻量级的数据交换格式(JavaScript Object Notation)，因其简单、可读性强广泛使用。&lt;/p&gt;

&lt;p&gt;JSON语法规则&lt;/p&gt;

&lt;p&gt;对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。&lt;/p&gt;

&lt;p&gt;数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。&lt;/p&gt;

&lt;p&gt;值（value）可以是双引号括起来的字符串（string）、数值(number)、true、false、 null、对象（object）或者数组（array）。这些结构可以嵌套。&lt;/p&gt;

&lt;p&gt;字符串（string）是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符（character）即一个单独的字符串（character string）。与C或者Java的字符串非常相似。&lt;/p&gt;

&lt;p&gt;比较下面两种数据的区别&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;{\&quot;class\&quot;:\&quot;1803班\&quot;, \&quot;Count\&quot;:\&quot;35\&quot;}&quot;
{&quot;class&quot;:&quot;1803班&quot;, &quot;Count&quot;:&quot;35&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据格式比较简单, 易于读写, 格式都是压缩的, 占用带宽小&lt;/li&gt;
  &lt;li&gt;易于解析这种语言, 客户端JavaScript可以简单的通过eval_r()进行JSON数据的读取&lt;/li&gt;
  &lt;li&gt;支持多种语言, 包括ActionScript, C, C#, ColdFusion, Java,JavaScript, Perl, PHP, Python, Ruby等语言服务器端语言, 便于服务器端的解析&lt;/li&gt;
  &lt;li&gt;在PHP世界, 已经有PHP-JSON和JSON-PHP出现了, 便于PHP序列化后的程序直接调用. PHP服务器端的对象、数组等能够直接生JSON格式, 便于客户端的访问提取.&lt;/li&gt;
  &lt;li&gt;因为JSON格式能够直接为服务器端代码使用, 大大简化了服务器端和客户端的代码开发量, 但是完成的任务不变, 且易于维护&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性&lt;/li&gt;
  &lt;li&gt;JSON格式目前在Web Service中推广还属于初级阶段&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-xml&quot;&gt;2. XML&lt;/h3&gt;

&lt;p&gt;扩展标记语言 (Extensible Markup Language,XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。&lt;/p&gt;

&lt;p&gt;XML一种类似于HTML的语言，他没有预先定义的标签。非常适合 Web 传输。&lt;/p&gt;

&lt;p&gt;XML相比之JSON这种轻量级的数据交换格式，XML可以称为重量级的了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;格式统一, 符合标准&lt;/li&gt;
  &lt;li&gt;容易与其他系统进行远程交互, 数据共享比较方便&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XML文件格式文件庞大, 格式复杂, 传输占用带宽&lt;/li&gt;
  &lt;li&gt;服务器端和客户端都需要花费大量代码来解析XML, 不论服务器端和客户端代码变的异常复杂和不容易维护&lt;/li&gt;
  &lt;li&gt;客户端不同浏览器之间解析XML的方式不一致, 需要重复编写很多代码&lt;/li&gt;
  &lt;li&gt;服务器端和客户端解析XML花费资源和时间&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-比较&quot;&gt;3. 比较&lt;/h3&gt;

&lt;p&gt;假如有一个employee对象，它有“姓、名、员工编号、头衔”等信息，先看看JSON是如何来描述它的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;employee&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;王&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;五&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;employeeNumber&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;客户经理&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再来看看XML是如何表示的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;employee&amp;gt;  
    &amp;lt;firstName&amp;gt;王&amp;lt;/firstName&amp;gt;  
    &amp;lt;lastName&amp;gt;五&amp;lt;/lastName&amp;gt;  
    &amp;lt;employeeNumber&amp;gt;123&amp;lt;/employeeNumber&amp;gt;  
    &amp;lt;title&amp;gt;客户经理&amp;lt;/title&amp;gt;  
&amp;lt;/employee&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;1-轻量级和重量级&quot;&gt;1. 轻量级和重量级&lt;/h5&gt;

&lt;p&gt;那么XML相对于JSON的重量级体现在哪呢?我想应该体现在解析上，XML目前设计了两种解析方式：DOM和 SAX;&lt;/p&gt;

&lt;p&gt;DOM是把一个数据交换格式XML看成一个DOM对象，需要把XML文件整个读入内存，这一点上JSON和XML的原理是一样的，但是XML要考虑父节点和子节点，这一点上JSON的解析难度要小很多，因为JSON构建于两种结构：key/value，键值对的集合;值的有序集合，可理解为数组;&lt;/p&gt;

&lt;p&gt;SAX不需要整个读入文档就可以对解析出的内容进行处理，是一种逐步解析的方法。程序也可以随时终止解析。这样，一个大的文档就可以逐步的、一点一点的展现出来，所以SAX适合于大规模的解析。这一点，JSON目前是做不到得。&lt;/p&gt;

&lt;p&gt;所以，JSON和XML的轻/重量级的区别在于：JSON只提供整体解析方案，而这种方法只在解析较少的数据时才能起到良好的效果;而XML提 供了对大规模数据的逐步解析方案，这种方案很适合于对大量数据的处理。&lt;/p&gt;

&lt;h5 id=&quot;2-编码及解析的难度&quot;&gt;2. 编码及解析的难度&lt;/h5&gt;

&lt;p&gt;编码：它们都是基于文本的，且它们都使用Unicode编码。&lt;/p&gt;

&lt;p&gt;解析：在普通的web应用领域，开发者经常为XML的解析伤脑筋，无论是服务器端生成或处理XML，还是客户端用 JavaScript解析XML，都常常导致复杂的代码，极低的开发效率。&lt;/p&gt;

&lt;p&gt;主观上来看，JSON更为清晰且冗余更少些。从总体来看，XML比较适合于标记文档，而JSON却更适于进行数据交换处理。&lt;/p&gt;

&lt;p&gt;实际上，对于大多数web应用来说，他们根本不需要复杂的XML来传输数据，XML宣称的扩展性在此就很少具有优势;许多Ajax应用甚至直接返回HTML片段来构建动态web页面。和返回XML并解析它相比，返回HTML片段大大降低了系统的复杂性，但同时缺少了一定的灵活性。同XML或 HTML片段相比，数据交换格式JSON 提供了更好的简单性和灵活性。在web serivice应用中，至少就目前来说XML仍有不可动摇的地位。&lt;/p&gt;

&lt;h1 id=&quot;编码格式&quot;&gt;编码格式：&lt;/h1&gt;

&lt;p&gt;我们最初学习计算机的时候，都学过ASCII编码。但是为了表示各种各样的语言，在计算机技术的发展过程中，逐渐出现了很多不同标准的编码格式，重要的有Unicode、UTF、ISO 8859-1和中国人经常使用的GB2312、BIG5、GBK等。&lt;/p&gt;

&lt;h3 id=&quot;1-asciiiso-8859-1&quot;&gt;1. ASCII/ISO 8859-1&lt;/h3&gt;

&lt;p&gt;ASCII是7位编码，能表示128个字符。每个ASCII字符占用1个字节（8bits）。&lt;/p&gt;

&lt;p&gt;ISO 8859-1最多能表示的字符范围是0-255（编码范围是0x00-0xFF），其中0x00-0x7F之间完全和ASCII一致，因此向下兼容ASCII。&lt;/p&gt;

&lt;h3 id=&quot;2-汉字编码-gb2312big5gbkgb18030&quot;&gt;2. 汉字编码 GB2312/BIG5/GBK/GB18030&lt;/h3&gt;

&lt;p&gt;GB2312是汉字的国标码，也是简体汉字编码规范。&lt;/p&gt;

&lt;p&gt;BIG5是中华民国政府制定的，是繁体汉字的编码规范。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GBK大字符集&lt;/strong&gt;，简而言之就是将所有亚洲文字的双字节字符，包括简体中文，繁体中文，日语，韩语等，都使用一种格式编码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GB18030&lt;/strong&gt;由&lt;strong&gt;GBK&lt;/strong&gt; 扩展，加入了少数名族汉子，GB18030 与 GB2312-1980 和 GBK 都兼容。目前最新最全的汉字编码。&lt;/p&gt;

&lt;h3 id=&quot;3-unicode&quot;&gt;3. Unicode&lt;/h3&gt;

&lt;p&gt;Unicode是最统一的编码，可以用来表示所有语言的字符，包括英文字母在内，都以双字节表示。是Unicode.org制定的编码标准，目前得到了绝大部分操作系统和编程语言的支持。&lt;/p&gt;

&lt;h3 id=&quot;4-utf&quot;&gt;4. UTF&lt;/h3&gt;

&lt;p&gt;因为对于英文字母，Unicode也需要两个字节来表示，所以Unicode不便于传输和存储。因此而产生了UTF编码。&lt;/p&gt;

&lt;p&gt;UTF-8编码它是一种变长的编码方式，对于只需要1个字节的字符，就使用一个字节；对于中日韩等Unicode中需要两个字节才能表示的字符，则通过一个 UTF16 – UTF8 的算法实现相互之间的转换（转换后的UTF-8一般需要3个字节）。兼容ISO 8859-1的编码。&lt;/p&gt;

&lt;p&gt;在计算机中一般使用Unicode编码再转换成UTF8编码进行存储。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Unicode是一种编码方式，和ACSII是同一个概念，而UTF是一种存储方式（格式）&lt;/strong&gt;。&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/09/JSON%E7%AE%80%E4%BB%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/09/JSON%E7%AE%80%E4%BB%8B/</guid>
        
        <category>go语言</category>
        
        
      </item>
    
  </channel>
</rss>
