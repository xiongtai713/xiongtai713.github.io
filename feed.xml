<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘蛟区块链博客</title>
    <description>区块链工程师</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 02 Jun 2018 21:38:08 +0800</pubDate>
    <lastBuildDate>Sat, 02 Jun 2018 21:38:08 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>区块链数据结构 </title>
        <description>&lt;p&gt;#区块数据结构&lt;/p&gt;

&lt;p&gt;在区块链中，区块是存储有价值信息的块。这是任何一种加密货币的本质。除此之外，区块还包含一些技术信息，比如它的版本、当前时间戳和前一区块的散列值（哈希值）&lt;/p&gt;

&lt;p&gt;Block（区块）是Ethereum的核心数据结构之一&lt;/p&gt;

&lt;p&gt;***** 所有账户的相关活动，以交易(Transaction)的格式存储，每个Block有一个交易对象的列表&lt;/p&gt;

&lt;p&gt;*** **每个交易的执行结果，由一个Receipt对象与其包含的一组Log对象记录&lt;/p&gt;

&lt;p&gt;***** 所有交易执行完后生成的Receipt列表，存储在Block中(经过压缩加密)&lt;/p&gt;

&lt;p&gt;***** 不同Block之间，通过前向指针ParentHash一个一个串联起来成为一个单向链表，BlockChain 结构体管理着这个链表&lt;/p&gt;

&lt;p&gt;***** Block结构体基本可分为Header和Body两个部分&lt;/p&gt;

&lt;p&gt;Block: 表示以太坊区块链中的一个完整块&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Block struct {
	header       *Header
	uncles       []*Header		// 块头(Header)
	transactions Transactions

	// caches
	hash atomic.Value
	size atomic.Value

	// Td is used by package core to store the total difficulty
	// of the chain up to and including the block.
	td *big.Int

	// These fields are used by package eth to track
	// inter-peer block relay.
	ReceivedAt   time.Time
	ReceivedFrom interface{}		// 块体(Body)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;在存储区块信息时，会将区块头和区块体分开进行存储。因此在区块的结构体中，能够看到Header和Body两个结构体&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Header: 表示以太坊区块链中的块头&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Header struct {
	ParentHash  common.Hash    `json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`
	UncleHash   common.Hash    `json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`
	Coinbase    common.Address `json:&quot;miner&quot;            gencodec:&quot;required&quot;`
	Root        common.Hash    `json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`
	TxHash      common.Hash    `json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`
	ReceiptHash common.Hash    `json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`
	Bloom       Bloom          `json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`
	Difficulty  *big.Int       `json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`
	Number      *big.Int       `json:&quot;number&quot;           gencodec:&quot;required&quot;`
	GasLimit    uint64         `json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`
	GasUsed     uint64         `json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`
	Time        *big.Int       `json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`
	Extra       []byte         `json:&quot;extraData&quot;        gencodec:&quot;required&quot;`
	MixDigest   common.Hash    `json:&quot;mixHash&quot;          gencodec:&quot;required&quot;`
	Nonce       BlockNonce     `json:&quot;nonce&quot;            gencodec:&quot;required&quot;`
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Body: 以太坊区块链中的交易信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Body is a simple (mutable, non-safe) data container for storing and moving
// a block's data contents (transactions and uncles) together.
type Body struct {
	Transactions []*Transaction
	Uncles       []*Header
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;header部分&quot;&gt;Header部分&lt;/h2&gt;

&lt;p&gt;Header是Block的核心，它的成员变量全都是公共的，可以很方便的向调用者提供关于Block属性的操作。Header的成员变量全都很重要，值得细细理解:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ParentHash：指向父区块(parentBlock)的指针。除了创世块(Genesis Block)外，每个区块有且只有一个父区块。&lt;/li&gt;
  &lt;li&gt;UncleHash：Block结构体的成员uncles的RLP哈希值。uncles是一个Header数组，它的存在，颇具匠心。&lt;/li&gt;
  &lt;li&gt;Coinbase：挖掘出这个区块的作者地址。在每次执行交易时系统会给与一定补偿的Ether，这笔金额就是发给这个地址的。&lt;/li&gt;
  &lt;li&gt;Root：StateDB中的“state Trie”的根节点的RLP哈希值。Block中，每个账户以stateObject对象表示，账户以Address为唯一标示，其信息在相关交易(Transaction)的执行中被修改。所有账户对象可以逐个插入一个Merkle-PatricaTrie(MPT)结构里，形成“state Trie”。&lt;/li&gt;
  &lt;li&gt;TxHash: Block中 “tx Trie”的根节点的RLP哈希值。Block的成员变量transactions中所有的tx对象，被逐个插入一个MPT结构，形成“tx Trie”。&lt;/li&gt;
  &lt;li&gt;ReceiptHash：Block中的 “Receipt Trie”的根节点的RLP哈希值。Block的所有Transaction执行完后会生成一个Receipt数组，这个数组中的所有Receipt被逐个插入一个MPT结构中，形成”Receipt Trie”。&lt;/li&gt;
  &lt;li&gt;Bloom：Bloom过滤器(Filter)，用来快速判断一个参数Log对象是否存在于一组已知的Log集合中。&lt;/li&gt;
  &lt;li&gt;Difficulty：区块的难度。Block的Difficulty由共识算法基于parentBlock的Time和Difficulty计算得出，它会应用在区块的‘挖掘’阶段。&lt;/li&gt;
  &lt;li&gt;Number：区块的序号。Block的Number等于其父区块Number +1。&lt;/li&gt;
  &lt;li&gt;GasLimit：区块内所有Gas消耗的理论上限。该数值在区块创建时设置，与父区块有关。具体来说，根据父区块的GasUsed同GasLimit * 2/3的大小关系来计算得出。&lt;/li&gt;
  &lt;li&gt;GasUsed：区块内所有Transaction执行时所实际消耗的Gas总和。&lt;/li&gt;
  &lt;li&gt;Time：区块“应该”被创建的时间。由共识算法确定，一般来说，要么等于parentBlock.Time + 10s，要么等于当前系统时间。&lt;/li&gt;
  &lt;li&gt;Nonce：一个64bit的哈希数，它被应用在区块的”挖掘”阶段，并且在使用中会被修改&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;body结构体&quot;&gt;Body结构体&lt;/h2&gt;

&lt;p&gt;Block的成员变量td 表示的是整个区块链表从源头创世块开始，到当前区块截止，累积的所有区块Difficulty之和，td 取名totalDifficulty。从概念上可知，某个区块与父区块的td之差，就等于该区块Header带有的Difficulty值。&lt;/p&gt;

&lt;p&gt;Body可以理解为Block里的数组成员集合，它相对于Header需要更多的内存空间，所以在数据传输和验证时，往往与Header是分开进行的。&lt;/p&gt;

&lt;p&gt;Uncles是Body非常特别的一个成员，从业务功能上说，它并不是Block结构体必须的，它的出现当然会占用整个Block计算哈希值时更长的时间，目的是为了抵消整个Ethereum网络中那些计算能力特别强大的节点会对区块的产生有过大的影响力，防止这些节点破坏“去中心化”这个根本宗旨。官方描述可见&lt;a href=&quot;https://github.com/ethereum/wiki/wiki/Design-Rationale#uncle-incentivization&quot;&gt;ethereum-wiki&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;block的唯一标识符&quot;&gt;Block的唯一标识符&lt;/h2&gt;

&lt;p&gt;Block对象的唯一标识符，就是它的(RLP)哈希值。需要注意的是，Block的哈希值，等于其Header成员的(RLP)哈希值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// core/types/block.go
// Hash returns the keccak256 hash of b's header.
// The hash is computed on the first call and cached thereafter.
func (b *Block) Hash() common.Hash {
	if hash := b.hash.Load(); hash != nil {	// 获取最近所设置的存储值
		return hash.(common.Hash)
	}
	v := b.header.Hash()	// 调用Head成员的Hash
	b.hash.Store(v)
	return v
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Block的成员hash会缓存上一次Header计算出的哈希值，以避免不必要的计算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Hash returns the block hash of the header, which is simply the keccak256 hash of its
// RLP encoding.
func (h *Header) Hash() common.Hash {
   return rlpHash(h)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func rlpHash(x interface{}) (h common.Hash) {
   hw := sha3.NewKeccak256()
   rlp.Encode(hw, x)
   hw.Sum(h[:0])
   return h
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加新块:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// NewBlock creates a new block. The input data is copied,
// changes to header and to the field values will not affect the
// block.
//
// The values of TxHash, UncleHash, ReceiptHash and Bloom in header
// are ignored and set to values derived from the given txs, uncles
// and receipts.
func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt) *Block {
	b := &amp;amp;Block{header: CopyHeader(header), td: new(big.Int)}

	// TODO: panic if len(txs) != len(receipts)
	if len(txs) == 0 {
		b.header.TxHash = EmptyRootHash
	} else {
		b.header.TxHash = DeriveSha(Transactions(txs))
		b.transactions = make(Transactions, len(txs))
		copy(b.transactions, txs)
	}

	if len(receipts) == 0 {
		b.header.ReceiptHash = EmptyRootHash
	} else {
		b.header.ReceiptHash = DeriveSha(Receipts(receipts))
		b.header.Bloom = CreateBloom(receipts)
	}

	if len(uncles) == 0 {
		b.header.UncleHash = EmptyUncleHash
	} else {
		b.header.UncleHash = CalcUncleHash(uncles)
		b.uncles = make([]*Header, len(uncles))
		for i := range uncles {
			b.uncles[i] = CopyHeader(uncles[i])
		}
	}

	return b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/02/%E5%8C%BA%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/02/%E5%8C%BA%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
        
        <category>区块链</category>
        
        
      </item>
    
      <item>
        <title> 交易的Hash </title>
        <description>&lt;h1 id=&quot;交易的hash&quot;&gt;交易的Hash&lt;/h1&gt;

&lt;p&gt;两个最常用的自定义数据类型&lt;strong&gt;common.Hash用来表示哈希值，common.Address&lt;/strong&gt;表示地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /commons/types.go  
const (  
    HashLength = 32  
    AddressLength = 20  
)  
type Hash [HashLength]byte  
type Address [AddressLength]byte  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在Ethereum 代码里，所有用到的哈希值，都使用该Hash类型，长度为32bytes，即256 bits；Ethereum 中所有跟帐号(Account)相关的信息，比如交易转帐的转出帐号(地址)和转入帐号(地址)，都会用该Address类型表示，长度20bytes。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;big.Int&lt;/strong&gt;是golang提供的数据类型，用来处理比较大的整型数，当然它也可以处理诸如64bit，32bit的常用整数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /go-1.x/src/math/big/int.go  
package big  
type Int struct {  
    neg bool  // sign, whether negaive  
    abs nat   // absolute value of integer  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;big.Int是一个结构体(struct)，相当于C++中的class，所以每次新建big.Int时可以用 x := new(big.Int), 返回一个指针。注意对Int的算术操作，要使用该对象的成员函数，比如Add():&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (z *Int) Add(x, y *Int) *Int   // Add sets z to sum x+y and returns z 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/02/%E4%BA%A4%E6%98%93%E7%9A%84Hash/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/02/%E4%BA%A4%E6%98%93%E7%9A%84Hash/</guid>
        
        <category>区块链</category>
        
        
      </item>
    
      <item>
        <title>交易数据结构</title>
        <description>&lt;p&gt;#交易数据结构&lt;/p&gt;

&lt;p&gt;##区块链转账的基本概念和流程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户输入转账的地址和转入的地址和转出的金额&lt;/li&gt;
  &lt;li&gt;系统通过转出的地址的私钥对转账信息进行签名（用于证明这笔交易确实由本人进行）&lt;/li&gt;
  &lt;li&gt;系统对交易信息进行验证&lt;/li&gt;
  &lt;li&gt;把这笔交易入到本地的txpool中（就是缓存交易池）&lt;/li&gt;
  &lt;li&gt;把交易信息广播给其它节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每条交易对应存储两条数据，一条是交易本身，一条是交易的元信息（meta）。交易以交易的hash为key、交易的RLP编码为value存储；元信息以txHash+txMetaSuffix为key、元信息的RLP编码为value存储。元信息中包含交易所在区块的区块hash、区块号、交易在区块中的索引。具体可以看WriteTransactions函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// hash size from是缓存字段
type Transaction struct {
	data txdata
	// caches
	hash atomic.Value
	size atomic.Value
	from atomic.Value
}

type txdata struct {
	AccountNonce uint64          `json:&quot;nonce&quot;    gencodec:&quot;required&quot;`
	Price        *big.Int        `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`
	GasLimit     uint64          `json:&quot;gas&quot;      gencodec:&quot;required&quot;`
	Recipient    *common.Address `json:&quot;to&quot;       rlp:&quot;nil&quot;` // nil means contract creation
	Amount       *big.Int        `json:&quot;value&quot;    gencodec:&quot;required&quot;`
	Payload      []byte          `json:&quot;input&quot;    gencodec:&quot;required&quot;`

	// Signature values
	V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;`
	R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;`
	S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;`

	// This is only used when marshaling to JSON.
	Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;`
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;AccountNonce:  发送者发起的交易总数量&lt;/p&gt;

&lt;p&gt;Price:		此次交易的gas价格&lt;/p&gt;

&lt;p&gt;GasLimit:	本次交易允许消耗的最大Gas数&lt;/p&gt;

&lt;p&gt;Recipient:	交易接收者的地址&lt;/p&gt;

&lt;p&gt;Amount:		此次交易转移的以太币数量&lt;/p&gt;

&lt;p&gt;Payload:		其它数据&lt;/p&gt;

&lt;p&gt;V:			交易的签名数据&lt;/p&gt;

&lt;p&gt;R:			交易的签名数据&lt;/p&gt;

&lt;p&gt;S:			交易的签名数据&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;txdata结构中没有指明交易的发送者，因为交易的发送者地址可以从签名中得到&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/02/%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/02/%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
        
        <category>区块链</category>
        
        
      </item>
    
      <item>
        <title>以太坊源码解析-go-ethereum代码阅读环境搭建</title>
        <description>&lt;h1 id=&quot;go-ethereum代码阅读环境搭建&quot;&gt;go-ethereum代码阅读环境搭建&lt;/h1&gt;

&lt;p&gt;安装GO&lt;/p&gt;

&lt;p&gt;配置环境变量(GOROOT, GOPATH, GOBIN)&lt;/p&gt;

&lt;p&gt;下载源码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd  $GOPATH; 
$ mkdir src
$ cd src  #进入go项目目录，创建src目录, 并进入src目录
$ git clone https://github.com/ethereum/go-ethereum
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用vim或其他IDE打开即可&lt;/p&gt;

&lt;p&gt;##windows 10 64bit&lt;/p&gt;

&lt;p&gt;安装GO&lt;/p&gt;

&lt;p&gt;配置环境变量(GOROOT, GOPATH, GOBIN)&lt;/p&gt;

&lt;p&gt;安装git工具，请参考网络上的教程安装git工具， go语言从github自动下载代码需要git工具的支持&lt;/p&gt;

&lt;p&gt;打开命令行工具下载 go-ethereum的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go get github.com/ethereum/go-ethereum
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;命令执行成功之后，代码就会下载到下面这个目录，%GOPATH%\src\github.com\ethereum\go-ethereum
如果执行过程中出现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# github.com/ethereum/go-ethereum/crypto/secp256k1
exec: &quot;gcc&quot;: executable file not found in %PATH%
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;则需要安装gcc工具，我们从下面地址下载并安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://tdm-gcc.tdragon.net/download
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装相应的IDE(Goland)&lt;/p&gt;

&lt;p&gt;##环境测试&lt;/p&gt;

&lt;p&gt;打开go-ethereum/rlp/decode_test.go. 在编辑框右键选择运行， 如果运行成功，代表环境搭建完成&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./picture/go_env_2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;##go ethereum 目录大概介绍&lt;/p&gt;

&lt;p&gt;go-ethereum项目的组织结构基本上是按照功能模块划分的目录，下面简单介绍一下各个目录的结构，每个目录在GO语言里面又被成为一个Package&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;accounts		实现了一个高等级的以太坊账户管理
bmt				二进制的默克尔树的实现
build			主要是编译和构建的一些脚本和配置
cmd				命令行工具，又分了很多的命令行工具
	/abigen		Source code generator to convert Ethereum contract definitions into easy to use, compile-time 
type-safe Go packages
	/bootnode	启动一个仅仅实现网络发现的节点
	/evm		以太坊虚拟机的开发工具， 用来提供一个可配置的，受隔离的代码调试环境
	/faucet		
	/geth		以太坊命令行客户端，最重要的一个工具
	/p2psim		提供了一个工具来模拟http的API
	/puppeth	创建一个新的以太坊网络的向导
	/rlpdump 	提供了一个RLP数据的格式化输出
	/swarm		swarm网络的接入点
	/util		提供了一些公共的工具
	/wnode		这是一个简单的Whisper节点。 它可以用作独立的引导节点。此外，可以用于不同的测试和诊断目的。
common			提供了一些公共的工具类
compression		Package rle implements the run-length encoding used for Ethereum data.
consensus		提供了以太坊的一些共识算法，比如ethhash, clique(proof-of-authority)
console			console类
contracts	
core			以太坊的核心数据结构和算法(虚拟机，状态，区块链，布隆过滤器)
crypto			加密和hash算法，
eth			实现了以太坊的协议
ethclient		提供了以太坊的RPC客户端
ethdb			eth的数据库(包括实际使用的leveldb和供测试使用的内存数据库)
ethstats		提供网络状态的报告
event			处理实时的事件
les			实现了以太坊的轻量级协议子集
light			实现为以太坊轻量级客户端提供按需检索的功能
log			提供对人机都友好的日志信息
metrics			提供磁盘计数器
miner			提供以太坊的区块创建和挖矿
mobile			移动端使用的一些warpper
node			以太坊的多种类型的节点
p2p			以太坊p2p网络协议
rlp			以太坊序列化处理
rpc			远程方法调用
swarm			swarm网络处理
tests			测试
trie			以太坊重要的数据结构Package trie implements Merkle Patricia Tries.
whisper			提供了whisper节点的协议。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/02/go-ethereum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/02/go-ethereum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
        
        <category>区块链</category>
        
        
      </item>
    
      <item>
        <title>etcd 多台服务器集群</title>
        <description>&lt;h1 id=&quot;etcd-多台服务器集群&quot;&gt;etcd 多台服务器集群&lt;/h1&gt;

&lt;h2 id=&quot;下载安装-etcd&quot;&gt;下载安装 etcd&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir -p $GOPATH/src/github.com/coreos
$ cd !$
$ git clone https://github.com/coreos/etcd.git
$ cd etcd
$ ./build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;启动服务&quot;&gt;启动服务&lt;/h2&gt;

&lt;p&gt;每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TOKEN=token-01
CLUSTER_STATE=new
NAME_1=machine-1
NAME_2=machine-2
NAME_3=machine-3
HOST_1=192.168.1.126
HOST_2=192.168.1.119
HOST_3=192.168.1.103
CLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;machine 1&lt;/strong&gt; 执行如下命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd/bin

# For machine 1
THIS_NAME=${NAME_1}
THIS_IP=${HOST_1}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;machine 2&lt;/strong&gt; 执行如下命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd/bin

# For machine 2
THIS_NAME=${NAME_2}
THIS_IP=${HOST_2}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;machine 3&lt;/strong&gt; 执行如下命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd/bin

# For machine 3
THIS_NAME=${NAME_3}
THIS_IP=${HOST_3}
./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检测服务器运行是否正常&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd/bin

export ETCDCTL_API=3
HOST_1=192.168.1.126
HOST_2=192.168.1.119
HOST_3=192.168.1.103
ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379

./etcdctl --endpoints=$ENDPOINTS member list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;存储数据&quot;&gt;存储数据&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./etcdctl --endpoints=$ENDPOINTS put foo &quot;Hello World!&quot;

./etcdctl --endpoints=$ENDPOINTS get foo
./etcdctl --endpoints=$ENDPOINTS --write-out=&quot;json&quot; get foo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;根据前缀查询&quot;&gt;根据前缀查询&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./etcdctl --endpoints=$ENDPOINTS put web1 value1
./etcdctl --endpoints=$ENDPOINTS put web2 value2
./etcdctl --endpoints=$ENDPOINTS put web3 value3

./etcdctl --endpoints=$ENDPOINTS get web --prefix

web1
value1
web2
value2
web3
value3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./etcdctl --endpoints=$ENDPOINTS put key myvalue
./etcdctl --endpoints=$ENDPOINTS del key

./etcdctl --endpoints=$ENDPOINTS put k1 value1
./etcdctl --endpoints=$ENDPOINTS put k2 value2
./etcdctl --endpoints=$ENDPOINTS del k --prefix
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;事务写入&quot;&gt;事务写入&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./etcdctl --endpoints=$ENDPOINTS put user1 bad
OK

$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive

compares:
// 输入以下内容，输入结束按 两次回车
value(&quot;user1&quot;) = &quot;bad&quot;      

//如果 user1 = bad，则执行 get user1 
success requests (get, put, del):
get user1

//如果 user1 != bad，则执行 put user1 good
failure requests (get, put, del):
put user1 good

// 运行结果，执行 success
SUCCESS

user1
bad



$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive
compares:
value(&quot;user1&quot;) = &quot;111&quot;  

// 如果 user1 = 111，则执行 get user1 
success requests (get, put, del):
get user1

//如果 user1 != 111，则执行 put user1 2222
failure requests (get, put, del):
put user1 2222

// 运行结果，执行 failure
FAILURE

OK

$ ./etcdctl --endpoints=$ENDPOINTS get user1
user1
2222
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;watch&quot;&gt;watch&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知
./etcdctl --endpoints=$ENDPOINTS watch stock1

// 新打开终端
$ cd $GOPATH/src/github.com/coreos/etcd/bin

export ETCDCTL_API=3
HOST_1=192.168.1.126
HOST_2=192.168.1.119
HOST_3=192.168.1.103
ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379
./etcdctl --endpoints=$ENDPOINTS put stock1 1000

./etcdctl --endpoints=$ENDPOINTS watch stock --prefix

./etcdctl --endpoints=$ENDPOINTS put stock1 10
./etcdctl --endpoints=$ENDPOINTS put stock2 20
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;更多操作&quot;&gt;更多操作&lt;/h2&gt;

&lt;p&gt;https://coreos.com/etcd/docs/latest/demo.html&lt;/p&gt;

</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/02/etcd-%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/02/etcd-%E5%A4%9A%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4/</guid>
        
        <category>etcd</category>
        
        
      </item>
    
      <item>
        <title>etcd使用</title>
        <description>&lt;h1 id=&quot;etcd---一个分布式一致性键值存储系统&quot;&gt;etcd - 一个分布式一致性键值存储系统&lt;/h1&gt;

&lt;p&gt;etcd是一个分布式一致性键值存储系统，用于共享配置和服务发现，专注于：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;简单:良好定义的，面向用户的API (gRPC)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安全： 带有可选客户端证书认证的自动TLS&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速:测试验证，每秒10000写入&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可靠:使用Raft适当分布&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;etcd是Go编写，并使用Raft一致性算法来管理高可用复制日志，架构如下图所示：&lt;/p&gt;

&lt;h2 id=&quot;下载安装&quot;&gt;下载安装&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir -p $GOPATH/src/github.com/coreos
$ cd !$
$ git clone https://github.com/coreos/etcd.git
$ cd etcd
$ ./build
$ ./bin/etcd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外一种下载安装的方法：&lt;/p&gt;

&lt;p&gt;直接下载etcd二进制 （包含etcd、etcdctl）
https://github.com/coreos/etcd/releases&lt;/p&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH
$ ./bin/etcd

$ cd $GOPATH
$ ETCDCTL_API=3 ./bin/etcdctl put foo bar

# 输出结果显示OK，表示安装成功
OK
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;搭建本地集群&quot;&gt;搭建本地集群&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ go get github.com/mattn/goreman

$ cd $GOPATH/src/github.com/coreos/etcd
$ goreman -f Procfile start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看本地集群的服务器列表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/coreos/etcd

$ ./bin/etcdctl member list

# 显示结果

8211f1d0f64f3269: name=infra1 peerURLs=http://127.0.0.1:12380 clientURLs=http://127.0.0.1:2379 isLeader=false
91bc3c398fb3c146: name=infra2 peerURLs=http://127.0.0.1:22380 clientURLs=http://127.0.0.1:22379 isLeader=true
fd422379fda50e48: name=infra3 peerURLs=http://127.0.0.1:32380 clientURLs=http://127.0.0.1:32379 isLeader=false

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;存储数据&quot;&gt;存储数据&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ETCDCTL_API=3

$ ./bin/etcdctl put foo &quot;Hello World!&quot;

OK

$ ./bin/etcdctl get foo

foo
Hello World!


$ ./bin/etcdctl  --write-out=&quot;json&quot; get foo

{&quot;header&quot;:{&quot;cluster_id&quot;:17237436991929493444,&quot;member_id&quot;:9372538179322589801,&quot;revision&quot;:2,&quot;raft_term&quot;:2},&quot;kvs&quot;:[{&quot;key&quot;:&quot;Zm9v&quot;,&quot;create_revision&quot;:2,&quot;mod_revision&quot;:2,&quot;version&quot;:1,&quot;value&quot;:&quot;SGVsbG8gV29ybGQh&quot;}],&quot;count&quot;:1}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;根据前缀查询&quot;&gt;根据前缀查询&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
$ ./bin/etcdctl put web1 value1
$ ./bin/etcdctl put web2 value2
$ ./bin/etcdctl put web3 value3

$ ./bin/etcdctl get web --prefix

web1
value1
web2
value2
web3
value3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;删除数据&quot;&gt;删除数据&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./bin/etcdctl put key myvalue
$ ./bin/etcdctl del key
1
$ ./bin/etcdctl get key
// 查询结果为空

$ ./bin/etcdctl put k1 value1
$ ./bin/etcdctl put k2 value2
$ ./bin/etcdctl del k --prefix
2
$ ./bin/etcdctl get k --prefix
// 查询结果为空
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;事务写入&quot;&gt;事务写入&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./bin/etcdctl put user1 bad
OK
$ ./bin/etcdctl txn --interactive

compares:
// 输入以下内容，输入结束按 两次回车
value(&quot;user1&quot;) = &quot;bad&quot;      

//如果 user1 = bad，则执行 get user1 
success requests (get, put, del):
get user1

//如果 user1 != bad，则执行 put user1 good
failure requests (get, put, del):
put user1 good

// 运行结果，执行 success
SUCCESS

user1
bad



$ ./bin/etcdctl txn --interactive
compares:
value(&quot;user1&quot;) = &quot;111&quot;  

// 如果 user1 = 111，则执行 get user1 
success requests (get, put, del):
get user1

//如果 user1 != 111，则执行 put user1 2222
failure requests (get, put, del):
put user1 2222

// 运行结果，执行 failure
FAILURE

OK

$ ./bin/etcdctl get user1
user1
2222
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;watch&quot;&gt;watch&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知
$ ./bin/etcdctl watch stock1

// 新打开终端
$ export ETCDCTL_API=3
$ ./bin/etcdctl put stock1 1000

//在watch 终端显示
PUT
stock1
1000


$ ./bin/etcdctl watch stock --prefix
$ ./bin/etcdctl put stock1 10
$ ./bin/etcdctl put stock2 20
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;lease&quot;&gt;lease&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./bin/etcdctl lease grant 300
# lease 326963a02758b527 granted with TTL(300s)

$ ./bin/etcdctl put sample value --lease=326963a02758b527
OK

$ ./bin/etcdctl get sample

$ ./bin/etcdctl lease keep-alive 326963a02758b520
$ ./bin/etcdctl lease revoke 326963a02758b527
lease 326963a02758b527 revoked

# or after 300 seconds
$ ./bin/etcdctl get sample
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;distributed-locks&quot;&gt;Distributed locks&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//第一终端
$ ./bin/etcdctl lock mutex1
mutex1/326963a02758b52d

# 第二终端
$ ./bin/etcdctl lock mutex1

// 当第一个终端结束了，第二个终端会显示
mutex1/326963a02758b531

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;elections&quot;&gt;Elections&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./bin/etcdctl elect one p1

one/326963a02758b539
p1


# another client with the same name blocks
$ ./bin/etcdctl elect one p2

//结束第一终端，第二终端显示
one/326963a02758b53e
p2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cluster-status&quot;&gt;Cluster status&lt;/h3&gt;

&lt;p&gt;集群状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./bin/etcdctl --write-out=table endpoint status

$ ./bin/etcdctl endpoint health
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;snapshot&quot;&gt;Snapshot&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/etcdctl snapshot save my.db

Snapshot saved at my.db

./bin/etcdctl --write-out=table snapshot status my.db
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;member&quot;&gt;Member&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./bin/etcdctl member list -w table
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/02/etcd-%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/02/etcd-%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid>
        
        <category>etcd</category>
        
        
      </item>
    
      <item>
        <title>TCP和UDP的区别</title>
        <description>&lt;h1 id=&quot;tcp和udp的区别&quot;&gt;TCP和UDP的区别&lt;/h1&gt;
&lt;p&gt;TCP UDP
TCP与UDP基本区别
  1.基于连接与无连接
  2.TCP要求系统资源较多，UDP较少； 
  3.UDP程序结构较简单 
  4.流模式（TCP）与数据报模式(UDP); 
  5.TCP保证数据正确性，UDP可能丢包 
  6.TCP保证数据顺序，UDP不保证 
　　
UDP应用场景：
  1.面向数据报方式
  2.网络数据大多为短消息 
  3.拥有大量Client
  4.对数据安全性无特殊要求
  5.网络负担非常重，但对响应速度要求高&lt;/p&gt;

&lt;p&gt;tcp需要确认对方在线,才能发送消息
  UDP不需要确认对方在不在线,就能发送信息&lt;/p&gt;

</description>
        <pubDate>Sat, 02 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/02/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/02/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
        
        <category>go</category>
        
        
      </item>
    
      <item>
        <title>拜占庭将军问题PBFT实用拜占庭容错</title>
        <description>&lt;h1 id=&quot;拜占庭将军问题&quot;&gt;拜占庭将军问题&lt;/h1&gt;
&lt;p&gt;BFT 拜占庭将军问题 30个节点当中必须有21个是可用的,才能完成这项任务&lt;/p&gt;

&lt;p&gt;客户端把信息”哈喽”给主节点A&lt;/p&gt;

&lt;p&gt;A发布信息”哈喽”给B,C,D&lt;/p&gt;

&lt;p&gt;B收到信息”哈喽”给A,C,D&lt;/p&gt;

&lt;p&gt;C收到信息”哈喽”给A,B,D&lt;/p&gt;

&lt;p&gt;D收到信息”哈喽”给A,B,C&lt;/p&gt;

&lt;p&gt;PBFT 实用拜占庭容错
信息广播后ABCD每个节点都有收到的”哈喽”,再把”哈喽”返回给客户端,
客户端收到ABCD回复的信息如果有有2条以上的 信息为”哈喽”,
那最终结果就是”哈喽”&lt;/p&gt;

&lt;p&gt;go来实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;os&quot;
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;io&quot;
)

//声明nodeInfo节点,代表各个小的王国
type nodeInfo struct {
	//节点名称
	id string
	//节点路径
	path string
	//http响应
	write http.ResponseWriter //跟终端进行交互
}

//创建map,存储各个国家的ip地址
var nodeTable = make(map[string]string)

func main() {
	//接收终端参数  先编译 然后运行./main 后面跟参数
	userID := os.Args[1] //1代表有一个参数
	fmt.Println(userID)
	//存储4个国家的Ip地址
	nodeTable = map[string]string{
		&quot;Apple&quot;:  &quot;localhost:11112&quot;,
		&quot;MS&quot;:     &quot;localhost:11113&quot;,
		&quot;Google&quot;: &quot;localhost:11114&quot;,
		&quot;IBM&quot;:    &quot;localhost:11115&quot;,
	}
	//创建国家对象
	node := nodeInfo{id: userID, path: nodeTable[userID]}
	//http协议的回调函数
	//http://localhost:1111/req?warTime=1111[0]&amp;amp;arTime=1112[1]
	http.HandleFunc(&quot;/req&quot;, node.request)
	//回调函数 通过/prePrepare
	http.HandleFunc(&quot;/prePrepare&quot;, node.prePrepare)
	//回调  通过/prepare
	http.HandleFunc(&quot;/prepare&quot;, node.prepare)
	http.HandleFunc(&quot;/commit&quot;,node.commit)

	//启动服务器  监听端口  如果有请求,会搜索handdleFunc里面的关键字
	 err := http.ListenAndServe(node.path, nil)
	if err != nil {
		fmt.Println(err)
	}

}
//writer http.ResponseWriter, request *http.Request固定格式
//http返回值					//https输入的值
//当http服务器,接收到网络请求并且/req 则回调request方法
func (node *nodeInfo) request(writer http.ResponseWriter, request *http.Request) {
	//该命令允许request请求参数
	//ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段

	request.ParseForm() //取参数  ?后面的参数
	if (len(request.Form[&quot;warTime&quot;]) &amp;gt; 0) {
		node.write = writer
		fmt.Println(&quot;主节点接收到的参数信息为&quot;, request.Form[&quot;warTime&quot;][0])
		//激活主节点后,向其他节点发送广播
		node.broadcast(request.Form[&quot;warTime&quot;][0], &quot;/prePrepare&quot;) //广播给其他节点
	}
}

//节点发送广播的方法
func (node *nodeInfo) broadcast(msg string, path string) { //msg要发送的内容 path要发送的ip地址和端口
	fmt.Println(&quot;广播&quot;, path) //1133
	//遍历所有节点
	for nodeId, url := range nodeTable {
		if nodeId == node.id { //如果是本身, 就跳过这次
			continue
		}
		//使当前节点外的节点做响应
		//向指定的url发出请求
		http.Get(&quot;http://&quot; + url + path + &quot;?warTime=&quot; + msg + &quot;&amp;amp;nodeId=&quot; + node.id)
	}
}

//接收广播后接收到的数据
func (node *nodeInfo) prePrepare(writer http.ResponseWriter, request *http.Request) {
	request.ParseForm() //啥意思?
	fmt.Println(&quot;接收到的广播&quot;, request.Form[&quot;warTime&quot;][0])
	//做判断
	if len(request.Form[&quot;warTime&quot;])&amp;gt;0{
		node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prepare&quot;)

	}
}

//接收子节点的广播
func (node *nodeInfo) prepare(writer http.ResponseWriter, request *http.Request) {
	request.ParseForm()
	//打印消息
	fmt.Println(&quot;接收到的广播&quot;, request.Form[&quot;warTime&quot;][0])
	//校验
	if len(request.Form[&quot;warTime&quot;])&amp;gt;0{
		node.authentication(request)
	}

}

var authenticationNodeMap =make(map[string]string)
var authenticationSuceess = false

//校验拜占庭
func (node *nodeInfo)authentication(request *http.Request)  {
	if !authenticationSuceess{
		if len(request.Form[&quot;nodeId&quot;])&amp;gt;0{
			authenticationNodeMap[request.Form[&quot;nodeId&quot;][0]]=&quot;OK&quot;
			//如果存了两个国家节点成功正确的返回了结果 就是true
			if len(authenticationNodeMap)&amp;gt;len(nodeTable)/3{
				authenticationSuceess=true
				node.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/commit&quot;)
			}

		}
	}
}

//返回成功响应
func (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request)  {
	if writer!=nil{
		fmt.Println(&quot;拜占庭校验成功&quot;)
	}
	io.WriteString(node.write,&quot;ok&quot;) //在网页显示
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95/</guid>
        
        <category>共识算法</category>
        
        
      </item>
    
      <item>
        <title>Raft一致性算法</title>
        <description>&lt;h1 id=&quot;raft--一致性算法日志存储&quot;&gt;Raft  一致性算法日志存储&lt;/h1&gt;
&lt;p&gt;Raft 是一种为了管理复制日志的一致性算法&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;raft的工作模式是一个Leader和多个Follower模式，即我们通常说的领导者-追随者模式,这种模式下需要解决的第一个问题就是Leader的选举问题。其次是如何把日志从Leader复制到所有Follower上去。这里先不关心安全和可靠性，只理解raft运行起来基本规则。raft中的server有三种状态，除了已经提到的Leader和Follower状态外，还有Candidate状态，即竞选者状态。下面是这三种状态的转化过程。&lt;/p&gt;

&lt;p&gt;1、Leader的选举过程
初始所有节点都是&lt;strong&gt;追随者&lt;/strong&gt;,并开始随机睡眠(0-1000毫秒),最先醒来的变成&lt;strong&gt;竞选者&lt;/strong&gt;,竞选者可以给让其他节点给投票,当得到一半以上的票数,就当选成&lt;strong&gt;领导者&lt;/strong&gt;,只有&lt;strong&gt;领导者&lt;/strong&gt;才有权利接收客户端发来的委托请求,并像其他节点发送请求来保存日志.
2、日志复制过程
&lt;strong&gt;领导者&lt;/strong&gt;给所有&lt;strong&gt;追随者&lt;/strong&gt;发送保存日志请求,追随者收到请求后,判断是否满足条件,如果满足,追随者就保存在本地,并且给领导者发送保存成功的信息,领导者收到大部分追随者回复的信息之后,领导者就会正式提交把日志保存在本地,然后会给追随者发送本条日志的保存信息,(包括领导者ID和任期等),追随者会验证这些信息,确认刚才的日志已经被提交,正式把日志保存在本地,就意味着本条日志正式被Raft系统接受.
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3021998-8fecbddc9bc69558.png&quot; alt=&quot;GitHub set up&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;领导者&lt;/strong&gt;具有绝对的日志复制权力其它&lt;strong&gt;追随者&lt;/strong&gt;上存在日志不全或者与&lt;strong&gt;领导者&lt;/strong&gt;日志不一致的情况时，一切都以&lt;strong&gt;领导者&lt;/strong&gt;上的日志为主，最终所有server上的日志都会复制成与&lt;strong&gt;领导者&lt;/strong&gt;一致的状态。&lt;/p&gt;

&lt;p&gt;#安全性保证
1.&lt;strong&gt;领导者&lt;/strong&gt;正常运作时，会周期性地发出append_entries请求。这个周期性的append_entries除了可以更新其它Follower的log信息，另外一个重要功能就是起到心跳作用。Follower收到append_entries后，就知道&lt;strong&gt;领导者&lt;/strong&gt;还活着。如果Follower经过一个预定的时间(一般设为2000ms左右)都没有收到&lt;strong&gt;领导者&lt;/strong&gt;的心跳，就认为Leader挂了。于是转入Candidate状态，开始发起投票竞选新的&lt;strong&gt;领导者&lt;/strong&gt;。每个新的&lt;strong&gt;领导者&lt;/strong&gt;产生后就是一个新的任期，每个任期都对应一个唯一的任期号term。这个term是单调递增的，用来唯一标识一个&lt;strong&gt;领导者&lt;/strong&gt;的任期。投票开始时，Candidate将自己的term加1，并在request_vote中带上term；Follower只会接受任期号term比自己大的request_vote请求，并为之投票。这条规则保证了只有最新的Candidate才有可能成为&lt;strong&gt;领导者&lt;/strong&gt;。
2.同时有俩位竞选者一起竞选,谁票数多谁当选,如果一样多,就继续睡从新选.
3.如果宕机很久,就不能竞选位领导者,只有拥有最新日志的节点,才能成为领导者
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3021998-b3b95d8d2d1f4341.png&quot; alt=&quot;&quot; /&gt;
判断如果lastLogTerm比自己的term大，那么就可以给它投票；lastLogTerm比自己的term小，就不给它投票&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;4.如果新增加服务器,Raft会添加一个中间配置(Cold, Cnew)，这个中间配置的内容是旧的配置表Cold和新的配置Cnew,比如说server3在竞选Leader的时候，不仅需要得到Cold中的大部分投票，还要得到Cnew中的大部分投票才能成为Leader
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3021998-5f5dd0487c633705.png&quot; alt=&quot;&quot; /&gt;
5.提交之前任期内的日志条目
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3021998-4306d3847460eb68.png&quot; alt=&quot;&quot; /&gt;
如果在c图中s1挂掉之前,把日志提交给大部分节点,s5由于没有最新的日志4号,就无法当选领导人,也就无法出现D图中的问题.&lt;/p&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/Raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/Raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</guid>
        
        <category>共识算法</category>
        
        
      </item>
    
      <item>
        <title>RPC网络框架</title>
        <description>&lt;p&gt;RPC框架 
用我电脑调用别的电脑里的函数
server 本台电脑
Area方法在Rect类型里
用其它的cilent来链接server,调用Rect里的Area方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;raft注册到rpc&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc.Register(Rect) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rpc通过handle(路由器)可以通过网线或者无线把rpc到handle里面&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc.HandleHTTP()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;rpc监听本机&lt;/strong&gt;  &lt;br /&gt;
通过tcp协议把自己作为主服务器去监听别的电脑或者客户端,参数有port(本机ip地址和接口)和handle(回调函数,回调go语言库defaultfunc,去比较本机的ip地址和其他电脑拨打的ip地址是否一致)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http.ListenAndServe(&quot;IP地址:端口号&quot;,&quot;nil&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他电脑进行拨打指定的ip地址及端口,如果和上边监听中的电脑ip地址一致,那么表示已经连上该机.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc1,err:=rpc.DialHTTP(&quot;TCP&quot;,&quot;要链接的IP地址:端口号&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;go实现服务器&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/rpc&quot;
	&quot;net/http&quot;
	&quot;log&quot;
)

//定义参数类型
type Params struct {
	Width, Height int
}

//声明对象
type Rect struct {
}

//定义公共方法 该方法在本机以外的方法也能调用
func (r *Rect) Area(p Params, ret *int) error {  //别人要调我的计算机的内存 所以要用指针
	*ret=p.Height*p.Width
	return nil
}

func (r *Rect)Perimtter(p Params, ret *int) error {
	*ret=(p.Width+p.Height)*2
	return nil

}

func main()  {
	//注册服务
	rect:=new(Rect)
	rpc.Register(rect)
	rpc.HandleHTTP() //不知道
	err:=http.ListenAndServe(&quot;:9090&quot;,nil)  //监听端头
	if err!=nil{
		log.Fatal(err)  //打印错误 并且写入日志
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;链接成功后返回rpc1,可以调用Call方法来调用server中的communication方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc1.Call(&quot;要调用的方法路径Rect.Area&quot;,&quot;要传入方法的参数&quot;,&quot;方法给的结果&amp;amp;&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;go实现客户端&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;net/rpc&quot;
	&quot;log&quot;
	&quot;fmt&quot;
)

//实现rpc客户端

type Params struct { //客户端要跟服务器保持一致
	Width, Height int
}

//调用服务器
func main() {
	//链接远程rpc
	rpc1,err:=rpc.DialHTTP(&quot;tcp&quot;,&quot;127.0.0.1:9090&quot;)//链接
	if err!=nil{
		log.Fatal(err)
	}
	ret:=0  //接收服务器传递的结果
	e:=rpc1.Call(&quot;Rect.Area&quot;,Params{100,100},&amp;amp;ret)

	if e!=nil{
		log.Fatal(e)
	}
	fmt.Println(ret)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果就是ret=100&lt;/p&gt;

</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/26/RPC%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/26/RPC%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</guid>
        
        <category>RPC框架</category>
        
        
      </item>
    
  </channel>
</rss>
